import java.util.Collection;
import java.util.ArrayList;

aspect ErrorCheck {
    public class SemanticError {
        ASTNode node;
        String message;
        
        public SemanticError(ASTNode node, String message) {
            this.node = node;
            this.message = message;
        }
        
        public ASTNode getNode() {
            return node;
        }
        
        public String getMessage() {
            return "Line " + node.getLine(node.getStart()) + ": " + message;
        }      
    }

    syn lazy Collection<SemanticError> Program.errors() {
        Collection<SemanticError> c = new ArrayList<SemanticError>();
        collectErrors(c);
        return c;
    }

    public void ASTNode.collectErrors(Collection<SemanticError> c) {
        for(int i = 0; i < getNumChild(); i++)
            getChild(i).collectErrors(c);
    }

    protected void ASTNode.error(Collection<SemanticError> c, String s) {
        c.add(new SemanticError(this, s));
    }
    
    // Don't error, if one of the types is unknown.
    // We already errored, when the unknown type was generated
    // Unknown identifier or unknown class/method.
    protected boolean ASTNode.isSubtypeOfIgnoreUnknown(TypeInfo t1, TypeInfo t2) {
        if (t1 instanceof TUnknown || t2 instanceof TUnknown)
            return true;
        
        return t1.isSubtypeOf(t2);
    }
    
    public void ClassDecl.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(hasCycleOnSuperclassChain())
            error(c, "Cyclic inheritance chain for class " + getIdent());
    }
    
    public void MethodDecl.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if (!isSubtypeOfIgnoreUnknown(getRetExp().type(), getRetType().type())) {
            getRetExp().error(c, "Invalid return type. Expected <" + getRetType().type() + ">, but got <" + getRetExp().type() + ">.");
        }
        
        if (overriddenMethod() != null) {
            TypeInfo superclassType = overriddenMethod().getRetType().type();
            TypeInfo myType = getRetType().type();
            if (overriddenMethod().getRetType().type().isSameType(getRetType().type())) {
                error(c, "Overridden method \"" + getIdent() + "\" has return type <" + superclassType + "> in super class " + overriddenMethod().containingClass().getIdent() + ", but <" + myType + "> here. They must match.");
            }
        }
    }
    
    public void Not.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if (type() instanceof TUnknown) {
            error(c, "Can't negate non-boolean expression.");
        }
    }
    
    public void Cmp.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(type() instanceof TUnknown) {
            error(c, "Comparison requires integer");
        }
    }
    
    public void IdentUse.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(decl() == null) {
            error(c, "Unknown Identifier \"" + getName() + "\"");
        }
    }

    public void ArrayAlloc.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!isSubtypeOfIgnoreUnknown(getSize().type(), intType())) {
            error(c, "Array size has to be integer, got <" + getSize().type() + ">");
        }        
    }
    
    public void ObjAlloc.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(decl() == null) {
            error(c, "Unknown Class \"" + getName() + "\"");
        }
    }
    
    public void This.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(decl() == null) {
            error(c, "Can't use \"this\" in MainClass");
        }
    }
    
    public void ArrayLookup.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!isSubtypeOfIgnoreUnknown(getExp().type(), intArrayType())) {
            error(c, "Expression is not an array");
        }
        if(!isSubtypeOfIgnoreUnknown(getOffset().type(), intType())) {
            error(c, "Array index has to be integer, got <" + getOffset().type() + ">");
        }
    }
    
    public void ArrayLength.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!isSubtypeOfIgnoreUnknown(getExp().type(), intArrayType())) {
            error(c, "Expression is not an array and has no length.");
        }
    }
    
    public void MethodCall.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(decl() == null) {
            error(c, "Unknown Method \"" + getName() + "\" on class \"" + getObj().type() + "\".");
            return;
        }
        
        if (decl().getFormalParamsList().getNumChild() != getArgsList().getNumChild()) {
            error(c, "Amount of arguments don't match the expected amount. (" + getArgsList().getNumChild() + " passed, " + decl().getFormalParamsList().getNumChild() + " expected)");
            return;
        }
        
        List<TypedVar> params = decl().getFormalParamsList();
        List<Exp> args = getArgsList();
        for(int i = 0; i < params.getNumChild(); i++) {
            if(!isSubtypeOfIgnoreUnknown(args.getChild(i).type(), params.getChild(i).type())) {
                error(c, "Mismatched Type for argument " + i + " expected <" + params.getChild(i).type() + ">, but got <" + args.getChild(i).type() + ">.");
            }
        }
    }
    
    public void Print.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!isSubtypeOfIgnoreUnknown(getExp().type(), intType())) {
            error(c, "Can only print integers, but got <"+ getExp().type() + ">.");
        }
    }
    
    public void Assign.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!isSubtypeOfIgnoreUnknown(getRhs().type(), getName().type())) {
            error(c, "Can't assign value of type <" + getRhs().type() + "> to variable of type <" + getName().type() + ">");
        }
    }
    
    public void ArrayAssign.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!isSubtypeOfIgnoreUnknown(getName().type(), intArrayType())) {
            error(c, getName().getName() + " is not an array");
        }
        if(!isSubtypeOfIgnoreUnknown(getOffset().type(), intType())) {
            error(c, "Array index has to be integer, got <" + getOffset().type() + ">");
        }
    }
    
    
    public void While.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!isSubtypeOfIgnoreUnknown(getCond().type(), booleanType())) {
            error(c, "Condition of while loop has to be boolean, got <" + getCond().type() +">");
        }
    }
    
    public void If.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!isSubtypeOfIgnoreUnknown(getCond().type(), booleanType())) {
            error(c, "Condition of if statement has to be boolean, got <" + getCond().type() +">");
        }
    }
    
    public void ClassT.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if (type() instanceof TUnknown) {
            error(c, "Class \"" + getName() + "\" not declared.");
        }
    }
    
    

}