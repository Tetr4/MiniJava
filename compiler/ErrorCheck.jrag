import java.util.Collection;
import java.util.ArrayList;

aspect ErrorCheck {
    public class SemanticError {
        ASTNode node;
        String message;
        
        public SemanticError(ASTNode node, String message) {
            this.node = node;
            this.message = message;
        }
        
        public ASTNode getNode() {
        	return node;
    	}
        
        public String getMessage() {
            return "Line " + node.getLine(node.getStart()) + ": " + message;
        }      
    }

    syn lazy Collection<SemanticError> Program.errors() {
        Collection<SemanticError> c = new ArrayList<SemanticError>();
        collectErrors(c);
        return c;
    }

    public void ASTNode.collectErrors(Collection<SemanticError> c) {
        for(int i = 0; i < getNumChild(); i++)
            getChild(i).collectErrors(c);
    }

    protected void ASTNode.error(Collection<SemanticError> c, String s) {
        c.add(new SemanticError(this, s));
    }
    
    public void Not.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if (type() instanceof TUnknown) {
            error(c, "Can't negate non-boolean expression.");
        }
    }
    
    public void Cmp.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(type() instanceof TUnknown) {
            error(c, "Comparison requires integer");
        }
    }
    
    public void IdentUse.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(decl() == null) {
            error(c, "Unknown Identifier \"" + getName() + "\"");
        }
    }

    public void ArrayAlloc.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!getSize().type().isSubtypeOf(intType())) {
            error(c, "Array size has to be integer, got <" + getSize().type() + ">");
        }        
    }
    
    public void ObjAlloc.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(decl() == null) {
            error(c, "Unknown Class \"" + getName() + "\"");
        }
    }
    
    public void ArrayLookup.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!getExp().type().isSubtypeOf(intArrayType())) {
            error(c, "Expression is not an array");
        }
        if(!getOffset().type().isSubtypeOf(intType())) {
            error(c, "Array index has to be integer, got <" + getOffset().type() + ">");
        }
    }
    
    public void ArrayLength.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!getExp().type().isSubtypeOf(intArrayType())) {
            error(c, "Expression is not an array and has no length.");
        }
    }
    
    public void MethodCall.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(decl() == null) {
            error(c, "Unknown Method \"" + getName() + "\"");
            return;
        }
        
        if (decl().getFormalParamsList().getNumChild() != getArgsList().getNumChild()) {
            error(c, "Amount of arguments don't match the expected amount. (" + getArgsList().getNumChild() + " passed, " + decl().getFormalParamsList().getNumChild() + " expected)");
            return;
        }
        
        List<TypedVar> params = decl().getFormalParamsList();
        List<Exp> args = getArgsList();
        for(int i = 0; i < params.getNumChild(); i++) {
            if(!args.getChild(i).type().isSubtypeOf(params.getChild(i).type())) {
                error(c, "Mismatched Type for argument " + i + " expected <" + params.getChild(i).type() + ">, but got <" + args.getChild(i).type() + ">.");
            }
        }
    }
    
    public void Print.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!getExp().type().isSubtypeOf(intType())) {
            error(c, "Can only print integers, but got <"+ getExp().type() + ">.");
        }
    }
    
    public void Assign.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!getRhs().type().isSubtypeOf(getName().type())) {
            error(c, "Can't assign value of type <" + getRhs().type() + "> to variable of type <" + getName().type() + ">");
        }
    }
    
    public void ArrayAssign.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!getName().type().isSubtypeOf(intArrayType())) {
            error(c, getName().getName() + " is not an array");
        }
        if(!getOffset().type().isSubtypeOf(intType())) {
            error(c, "Array index has to be integer, got <" + getOffset().type() + ">");
        }
    }
    
    
    public void While.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!getCond().type().isSubtypeOf(booleanType())) {
            error(c, "Condition of while loop has to be boolean, got <" + getCond().type() +">");
        }
    }
    
    public void If.collectErrors(Collection<SemanticError> c) {
        super.collectErrors(c);
        if(!getCond().type().isSubtypeOf(booleanType())) {
            error(c, "Condition of if statement has to be boolean, got <" + getCond().type() +">");
        }
    }
    
    
    
    
    
    

}