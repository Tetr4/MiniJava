 // this code is inlined before the generated parser
%header {:
package minijava;
:};

%terminals INTEGER, IDENTIFIER, PUBLIC, STATIC, VOID, MAIN, STRINGTYPE, SYSOUT;
%terminals LBRACE, RBRACE, LCURLYBRACE, RCURLYBRACE, LBRACKET, RBRACKET;
%terminals COMMA, DOT, PLUS, MINUS, TIMES, AND, BANG, LESSTHAN, SEMICOLON, EQUALS;
%terminals IF, ELSE, WHILE, CLASS, EXTENDS, RETURN, TRUE, FALSE;
%terminals INTTYPE, BOOLEAN, THIS, NEW, LENGTH;

%typeof Goal = "Program";
%typeof MainClass = "MainClass";
%typeof ClassList = "List<ClassDecl>";
%typeof ClassDecl = "ClassDecl";
%typeof VarList = "List<VarDecl>";
%typeof VarDecl = "VarDecl";
%typeof MethodList = "List<Method>";
%typeof Method = "Method";
%typeof Type = "Type";
%typeof Expression = "Expression";
%typeof ExpList = "List<Expression>";
%typeof Conditional = "Expression";
%typeof Relational = "Expression";
%typeof Addition = "Expression";
%typeof Multiplication = "Expression";
%typeof Unary = "Expression";
%typeof Primary = "Expression";
%typeof Postfix = "Expression";
%typeof Prefix = "Expression";
%typeof Primitive = "Expression";
%typeof ParamList = "List<Parameter>";
%typeof StatementList = "List<Statement>";
%typeof Statement = "Statement";
%typeof Id = "String";

%typeof BOOLEAN = "String";
%typeof INTTYPE = "String";
%typeof INTEGER = "String";

%goal Goal;

// Productions with semantic actions building the JastAdd AST
Goal = MainClass.main ClassList.classes
	 {: return new Program(main, classes); :}
	 | MainClass.main
	 {: return new Program(main, new List<ClassDecl>()); :}
;

MainClass = CLASS Id.name
            LCURLYBRACE 
                PUBLIC STATIC VOID MAIN LBRACE STRINGTYPE LBRACKET RBRACKET Id.arg RBRACE
                LCURLYBRACE 
                    VarList.vars
                    StatementList.stmts
                RCURLYBRACE
            RCURLYBRACE
            {: return new MainClass(name, arg, vars, stmts); :}
          | CLASS Id.name
            LCURLYBRACE 
                PUBLIC STATIC VOID MAIN LBRACE STRINGTYPE LBRACKET RBRACKET Id.arg RBRACE
                LCURLYBRACE 
                    StatementList.stmts
                RCURLYBRACE
            RCURLYBRACE
            {: return new MainClass(name, arg, new List<VarDecl>(), stmts); :}
          | CLASS Id.name
            LCURLYBRACE 
                PUBLIC STATIC VOID MAIN LBRACE STRINGTYPE LBRACKET RBRACKET Id.arg RBRACE
                LCURLYBRACE 
                    VarList.vars
                RCURLYBRACE
            RCURLYBRACE
            {: return new MainClass(name, arg, vars, new List<Statement>()); :}
          | CLASS Id.name
            LCURLYBRACE 
                PUBLIC STATIC VOID MAIN LBRACE STRINGTYPE LBRACKET RBRACKET Id.arg RBRACE
                LCURLYBRACE 
                RCURLYBRACE
            RCURLYBRACE
            {: return new MainClass(name, arg, new List<VarDecl>(), new List<Statement>()); :}
;

ClassDecl = CLASS Id.name
            LCURLYBRACE
                VarList.vars?
                MethodList.methods?
            RCURLYBRACE
            {: return new ClassDecl(name, "", vars==null?new List<VarDecl>():vars, methods==null?new List<Method>():methods); :}
          | CLASS Id.name EXTENDS Id.superClass
            LCURLYBRACE
                VarList.vars?
                MethodList.methods?
            RCURLYBRACE
            {: return new ClassDecl(name, superClass, vars==null?new List<VarDecl>():vars, methods==null?new List<Method>():methods); :}
;

ClassList = ClassDecl.c
            {:
                List list = new List();
                list.add(c);
                return new Symbol(list);
            :}
          | ClassList.list ClassDecl.c
            {:
                list.add(c);
                return _symbol_list;
            :}
;

VarDecl = Type.t Id.id SEMICOLON {: return new VarDecl(t, id); :}
;

VarList = VarDecl.v
          {:
              List list = new List<VarDecl>();
              list.add(v);
              return new Symbol(list);
          :}
        | VarList.list VarDecl.v
          {:
              list.add(v);
              return _symbol_list;
          :}
;

Method = PUBLIC Type.returnType Id.name LBRACE ParamList.params? RBRACE
         LCURLYBRACE
             VarList.vars
             StatementList.stmts
             RETURN Expression.returnExpr SEMICOLON
         RCURLYBRACE
         {: return new Method(returnType, name, params==null?new List<Parameter>():params, vars, stmts, returnExpr); :}
       | PUBLIC Type.returnType Id.name LBRACE ParamList.params? RBRACE
         LCURLYBRACE
             VarList.vars
             RETURN Expression.returnExpr SEMICOLON
         RCURLYBRACE
         {: return new Method(returnType, name, params==null?new List<Parameter>():params, vars, new List<Statement>(), returnExpr); :}
       | PUBLIC Type.returnType Id.name LBRACE ParamList.params? RBRACE
         LCURLYBRACE
             StatementList.stmts
             RETURN Expression.returnExpr SEMICOLON
         RCURLYBRACE
         {: return new Method(returnType, name, params==null?new List<Parameter>():params, new List<VarDecl>(), stmts, returnExpr); :}
       | PUBLIC Type.returnType Id.name LBRACE ParamList.params? RBRACE
         LCURLYBRACE
             RETURN Expression.returnExpr SEMICOLON
         RCURLYBRACE
         {: return new Method(returnType, name, params==null?new List<Parameter>():params, new List<VarDecl>(), new List<Statement>(), returnExpr); :}
;

MethodList = Method.m
             {: 
                 List list = new List<Method>();
                 list.add(m);
                 return new Symbol(list);
             :}
           | MethodList.list Method.m
             {:
                 list.add(m);
                 return _symbol_list;
             :}
;

ParamList = Type.t Id.id
            {:
                List lst = new List<Parameter>();
                lst.add(new Parameter(t, id));
                return new Symbol(lst);
            :}
          | ParamList.lst COMMA Type.t Id.id
            {:
                lst.add(new Parameter(t, id));
                return _symbol_lst;
            :}
;

Type = INTTYPE LBRACKET RBRACKET {: return new Type("int[]"); :} 
     | BOOLEAN.b {: return new Type(b); :}
     | INTTYPE.i {: return new Type(i); :}
     | Id.id  {: return new Type(id); :}
;

Statement = LCURLYBRACE StatementList.stmts RCURLYBRACE {: return new Block(stmts); :}
		  | LCURLYBRACE RCURLYBRACE {: return new Block(new List<Statement>()); :}
          | IF LBRACE Expression.condition RBRACE Statement.trueBranch ELSE Statement.falseBranch {: return new IfElse(condition, trueBranch, falseBranch); :}
          | WHILE LBRACE Expression.condition RBRACE Statement.body {: return new WhileLoop(condition, body); :}
          | SYSOUT LBRACE Expression.expr RBRACE SEMICOLON {: return new PrintLine(expr); :}
          | Id.var EQUALS Expression.value SEMICOLON {: return new Assignment(var, value); :}
          | Id.var LBRACKET Expression.index RBRACKET EQUALS Expression.value SEMICOLON {: return new ArrayAssignment(var, index, value); :}
;

StatementList = Statement.s
                {: List list = new List<Statement>();
                    list.add(s);
                    return new Symbol(list);
                :}
              | StatementList.list Statement.s
                {:
                    list.add(s);
                    return _symbol_list;
                :}
;

Expression = Conditional;

ExpList = Expression.e
          {: 
              List list = new List();
              list.add(e);
              return new Symbol(list);
          :}
        | ExpList.list COMMA Expression.e
          {:
              list.add(e);
              return _symbol_list;
          :}
;

Conditional = Relational
			| Relational.lhs AND Conditional.rhs
			{: return new BinaryExpression(new And(), lhs, rhs); :}
;

Relational = Addition
		   | Addition.lhs LESSTHAN Relational.rhs
		   {: return new BinaryExpression(new LessThan(), lhs, rhs); :}
;

Addition = Multiplication
		 | Multiplication.lhs PLUS Addition.rhs
		 {: return new BinaryExpression(new Plus(), lhs, rhs); :}
		 | Multiplication.lhs MINUS Addition.rhs
		 {: return new BinaryExpression(new Minus(), lhs, rhs); :}
;

Multiplication = Unary
			   | Unary.lhs TIMES Multiplication.rhs
			   {: return new BinaryExpression(new Times(), lhs, rhs); :}
;

Unary = BANG Unary.expr {: return new Negation(expr); :}
	  | NEW INTTYPE LBRACKET Expression.size RBRACKET {: return new IntArrayInstantiation(size); :}
      | NEW Id.classname LBRACE RBRACE {: return new Instantiation(classname); :}
	  | Postfix
;

Postfix = Primary.var DOT LENGTH {: return new LengthAccess(var); :}
        | Primary
;

Primary = Prefix.var DOT Id.methodname LBRACE ExpList.args? RBRACE 
		  {: return new Call(var, methodname, args==null?new List<Expression>():args); :}
		| Prefix.var LBRACKET Expression.index RBRACKET
		  {: return new ArrayAccess(var, index); :}
		| Prefix
;

Prefix = Id.id {: return new Identifier(id); :}
	   | THIS {: return new This(); :}
	   | LBRACE Expression.expr RBRACE {: return new BracedExpression(expr); :}
	   | Primitive
;

Primitive = INTEGER.i {: return new ConstInt(Integer.parseInt(i)); :}
		  | TRUE {: return new True(); :}
          | FALSE {: return new False(); :}
;

Id = IDENTIFIER
;