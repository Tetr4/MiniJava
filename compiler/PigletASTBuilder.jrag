import piglet.*;

aspect PigletASTBuilder {
    // TODO boolean encoding
    // TODO objects (virtual tables, fields)
    // TODO Translate classes
    
    syn lazy piglet.Program Program.toPiglet() {
        piglet.List<piglet.Procedure> procedures = new piglet.List<piglet.Procedure>();
        procedures.add(createArrayAllocProcedure());
        procedures.add(createArrayLookupProcedure());
        for (ClassDecl classDecl: getDeclsList()) {
        //    procedures.add((piglet.Procs) classDecl.toPiglet());
        }
        return new piglet.Program(getMain().getPigletStmts(), procedures);
    }
    
    
    
    /*
     * DECLARATIONS
     */
    
    public piglet.Temp TypedVar.temp = null;
    // TODO throw exception if temp is still null!
    syn piglet.Temp TypedVar.temp() = temp;
     
    syn lazy piglet.List<piglet.LabeledStmt> MainClass.getPigletStmts() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // Assign local vars a temporary identifier
        int i = 0;
        for (TypedVar localVar: getLocalVarsList()) {
            localVar.temp = new piglet.Temp(i++);
        }
        
        // Translate statments
        for (Stmt stmt: getStmtsList()) {
            for (piglet.LabeledStmt pigletStmt: stmt.toPiglet()) {
                labeledStmts.add(pigletStmt);
            }
        }
        
        return labeledStmts;
    }
    
    syn lazy piglet.List<piglet.LabeledStmt> ClassDecl.getPigletStmts() {
        // TODO initialize newly allocated fields with zero.
        return null;
    }
    
    syn lazy piglet.List<piglet.Procedure> ClassDecl.getProcedures() {
        // TODO
        return null;
    }
    
    syn lazy piglet.Procedure MethodDecl.toPiglet() {
        // TODO
        return null;
    }
    
    
    
    /*
     * STATEMENTS
     */

    syn lazy piglet.List<piglet.LabeledStmt> Stmt.toPiglet();
    
    eq Block.toPiglet() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // Translate statments
        for (Stmt stmt: getStmtsList()) {
            for (piglet.LabeledStmt pigletStmt: stmt.toPiglet()) {
                labeledStmts.add(pigletStmt);
            }
        }
        return labeledStmts;
    }
    
    public static int If.labelIndex = 0;
    eq If.toPiglet() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // create labels
        piglet.Label elseLabel = new piglet.Label("else_" + labelIndex);
        piglet.Label exitLabel = new piglet.Label("skipelse_" + labelIndex);
        labelIndex++;
        
        // Condition
        piglet.Exp condition = getCond().toPiglet();
        piglet.CJump elseJump = new piglet.CJump(condition, elseLabel);
        labeledStmts.add(convertToLabeledStmt(elseJump));
        
        // True branch
        piglet.List<piglet.LabeledStmt> trueBranchStmts = getTStmt().toPiglet();
        for (piglet.LabeledStmt labeledStmt: trueBranchStmts) {
            labeledStmts.add(labeledStmt);
        }
        
        // Skip to exit (skip else branch after true branch)
        piglet.Jump exitJump = new piglet.Jump(exitLabel);
        labeledStmts.add(convertToLabeledStmt(exitJump));
        
        // Else label
        labeledStmts.add(convertToLabeledStmt(elseLabel, new piglet.Noop()));
        
        // False branch
        piglet.List<piglet.LabeledStmt> falseBranchStmts = getFStmt().toPiglet();
        for (piglet.LabeledStmt labeledStmt: falseBranchStmts) {
            labeledStmts.add(labeledStmt);
        }
        
        // Exit label
        labeledStmts.add(convertToLabeledStmt(exitLabel, new piglet.Noop()));
        
        return labeledStmts;
    }
    
    public static int While.labelIndex = 0;
    eq While.toPiglet() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // create labels
        piglet.Label entryLabel = new piglet.Label("loop_" + labelIndex);
        piglet.Label exitLabel = new piglet.Label("loopexit_" + labelIndex);
        labelIndex++;
        
        // condition
        piglet.Exp condition = getCond().toPiglet();
        piglet.CJump jump = new piglet.CJump(condition, exitLabel);
        labeledStmts.add(convertToLabeledStmt(entryLabel, jump));
        
        // body
        piglet.List<piglet.LabeledStmt> bodyStmts = getBody().toPiglet();
        for (piglet.LabeledStmt labeledStmt: bodyStmts) {
            labeledStmts.add(labeledStmt);
        }
        
        // backedge
        piglet.Jump backJump = new piglet.Jump(entryLabel);
        labeledStmts.add(convertToLabeledStmt(backJump));
        
        // exit label
        labeledStmts.add(convertToLabeledStmt(exitLabel, new piglet.Noop()));
        
        return labeledStmts;
    }
    
    eq Assign.toPiglet() {
        piglet.Temp lhs = getName().decl().temp();
        piglet.Exp rhs = getRhs().toPiglet();
        return convertToLabeledStmts(new piglet.Move(lhs, rhs));
    }
    
    eq Print.toPiglet() {
        return convertToLabeledStmts(new piglet.Print(getExp().toPiglet()));
    }
    
    eq ArrayAssign.toPiglet() {
        piglet.Exp lhs = getName().toPiglet();
        piglet.Exp rhs = getExp().toPiglet();
        piglet.Exp offset = getOffset().toPiglet();
        
        // TODO check at run-time for „index out of bounds “
        // offset > length --> new piglet.Err();
        
        //address = lhs + (offset*4)
        piglet.Exp offsetInBytes = new piglet.Times(offset, new piglet.IntLiteral(4));
        piglet.Exp address = new piglet.Plus(lhs, offsetInBytes);
        
        // length in first 4 bytes -> <Offset:Integer> = 4
        return convertToLabeledStmts(new piglet.HStore(address, 4, rhs));
    }



    /*
     * EXPRESSIONS
     */
     
    syn lazy piglet.Exp Exp.toPiglet();
    
    eq Cmp.toPiglet() {
        return new piglet.Lt(getLeft().toPiglet(), getRight().toPiglet());
    }
    
    eq Add.toPiglet() {
        return new piglet.Plus(getLeft().toPiglet(), getRight().toPiglet());
    }
    eq Sub.toPiglet() {
        return new piglet.Minus(getLeft().toPiglet(), getRight().toPiglet());
    }
    eq Mult.toPiglet() {
        return new piglet.Times(getLeft().toPiglet(), getRight().toPiglet());
    }

    eq Not.toPiglet() {
        // !boolean == boolean < 1
        // 1 < 1 => 0
        // 0 < 1 => 1
        return new piglet.Lt(getExp().toPiglet(), new piglet.IntLiteral(1));
    }

    eq IdentUse.toPiglet() {
        return new piglet.TempExp(decl().temp());
    }

    eq IntLiteral.toPiglet() {
        return new piglet.IntLiteral(getInteger());
    }
    
    eq True.toPiglet() {
        return new piglet.IntLiteral(1);
    }
    
    eq False.toPiglet() {
        return new piglet.IntLiteral(0);
    }
    
    eq ArrayAlloc.toPiglet() {
        // Call ARRAYALLOC procedure
        piglet.Exp name = new LabelExp(new Label("ARRAYALLOC"));
        
        piglet.List<piglet.Exp> params = new piglet.List<piglet.Exp>();
        params.add(getSize().toPiglet());
        
        return new piglet.Call(name, params);
    }
    
    eq ObjAlloc.toPiglet() {
        // TODO 
        return new piglet.IntLiteral(1337);
    }
    
    eq ArrayLookup.toPiglet() {
        // Call ARRAYLOOKUP procedure
        piglet.Exp name = new LabelExp(new Label("ARRAYLOOKUP"));
        
        piglet.List<piglet.Exp> params = new piglet.List<piglet.Exp>();
        params.add(getExp().toPiglet());
        params.add(getOffset().toPiglet());
        
        return new piglet.Call(name, params);
    }
    
    eq ArrayLength.toPiglet() {
        // TODO
        return new piglet.IntLiteral(1337);    
    }
    
    eq MethodCall.toPiglet() {
        // TODO 
        return new piglet.IntLiteral(1337);    
    }
    
    eq This.toPiglet() {
        // TODO
        return new piglet.IntLiteral(1337);    
    }
    
    eq And.toPiglet() {
        // TODO
        return new piglet.IntLiteral(1337);     
    }
    
    
    
    /*
     * HELPERS
     */
     
    syn piglet.List<piglet.LabeledStmt> ASTNode.convertToLabeledStmts(piglet.List<piglet.Stmt> stmts) {
        piglet.List<piglet.LabeledStmt> list = new piglet.List<piglet.LabeledStmt>();
        for (piglet.Stmt stmt: stmts) {
            list.add(new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(), stmt));
        }
        return list;
    }
    
    syn piglet.List<piglet.LabeledStmt> ASTNode.convertToLabeledStmts(piglet.Stmt stmt) {
        piglet.List<piglet.LabeledStmt> list = new piglet.List<piglet.LabeledStmt>();
        list.add(new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(), stmt));
        return list;
    }
    
    syn piglet.LabeledStmt ASTNode.convertToLabeledStmt(piglet.Stmt stmt) {
        return new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(), stmt);
    }
    
    syn piglet.LabeledStmt ASTNode.convertToLabeledStmt(piglet.Label label, piglet.Stmt stmt) {
        return new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(label), stmt);
    }
    
    syn lazy piglet.Procedure ASTNode.createArrayAllocProcedure() {
        // Create a procedure 
        piglet.Label label = new piglet.Label("ARRAYALLOC");
        int paramCount = 1;
        
        // params
        piglet.Exp size = new TempExp(new piglet.Temp(0)); // first param
        
        // calculate size in byte. first 4 bytes are reserved for length
        // sizeInBytes = size*4 + 4
        piglet.Exp sizeInBytes = new piglet.Times(size, new piglet.IntLiteral(4));
        piglet.Exp sizeInByteWithLength = new piglet.Plus(sizeInBytes, new piglet.IntLiteral(4));
        
        // Statements
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        // TODO store length as first 4 bytes
        // TODO initialize rest with zeros  
        
        // return address of allocated memory block
        piglet.Exp retExp = new piglet.HAlloc(sizeInByteWithLength);
        
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, retExp);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    syn lazy piglet.Procedure ASTNode.createArrayLookupProcedure() {
        piglet.Label label = new piglet.Label("ARRAYLOOKUP");
        int paramCount = 2;
        
        // params
        piglet.Exp arrayAdress = new TempExp(new piglet.Temp(0)); // first param
        piglet.Exp offset = new TempExp(new piglet.Temp(1)); // second param
        
        // TODO check at run-time for „index out of bounds “
        // offset > length --> new piglet.Err();
        
        // address = arrayAdress + 4 + (offset*4)
        piglet.Exp offsetInBytes = new piglet.Times(offset, new piglet.IntLiteral(4));
        piglet.Exp address = new piglet.Plus(arrayAdress, offsetInBytes);
        
        // Statements  
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();  
        // load result into temp, which will be returned
        piglet.Temp temp = new piglet.Temp(2);
        piglet.HLoad hload = new piglet.HLoad(temp, address, 4); // length offset = 4 bytes
        labeledStmts.add(convertToLabeledStmt(hload));
        
        // return temp with value at adress
        piglet.Exp retExp = new TempExp(temp);
        
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, retExp);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
}