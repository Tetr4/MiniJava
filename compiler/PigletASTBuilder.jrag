import piglet.*;
import java.util.ArrayList;

aspect PigletASTBuilder {
    
    syn lazy piglet.Program Program.toPiglet() {
        piglet.List<piglet.Procedure> procedures = new piglet.List<piglet.Procedure>();
        
        // helper procedures
        procedures.add(createArrayAllocProcedure());
        procedures.add(createArrayLookupProcedure());
        procedures.add(createArrayLengthProcedure());
        procedures.add(createObjNullCheckProcedure());
        procedures.add(createObjectAllocProcedure());
        procedures.add(createObjectFieldAccessProcedure());

        // Assign index to classes in order of declaration
        // Ignore classes that don't need a virtual table (no methods or no changed methods regarding superclass)
        int numClassesWithMethods = setupClassIndices();
        
        // Prepare classes and translate all methods of all classes to procedures.
        for (ClassDecl classDecl: getDeclsList()) {
            // Assign proper field offsets to TypedVars
            // Start at offset 8, because of vtable list as first and vtable pointer as second element.
            classDecl.setupClassFields(8);
        
            // Assign indices to methods starting at the superclass with 0.
            classDecl.setupMethods(0);
            
        
            for(piglet.Procedure procedure: classDecl.getProcedures()) {
                procedures.add(procedure);
            }
        }
        
        // Generate virtual method tables for all classes
        // Generate a vtable_list with all the vtables of the classes.
        // This vtable list is passed around in method calls next to the this pointer.
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        piglet.HAlloc vtableListBase = new piglet.HAlloc(new piglet.IntLiteral(numClassesWithMethods * 4));
        
        // Save address of vtable list in TEMP 0.
        piglet.Temp vtableList = new piglet.Temp(0);
        piglet.Move saveVtableListAddress = new piglet.Move(vtableList, vtableListBase);
        labeledStmts.add(convertToLabeledStmt(saveVtableListAddress));
        
        // Start at 1 - TEMP 0 is reserved for vtable_list
        int tempIndex = 1;
        
        for (ClassDecl classDecl: getDeclsList()) {
            
            // This class has no methods at all? Don't bother generating a vtable.
            if (classDecl.getMethodCountInClassChain() == 0) {
                continue;
            }
            
            // Allocate enough space for all the procedure addresses
            piglet.HAlloc vtableBase = new piglet.HAlloc(new piglet.IntLiteral(classDecl.getMethodCountInClassChain() * 4));
            piglet.Temp vtableAddress = new piglet.Temp(tempIndex);
            tempIndex++;
            
            // Save the address in a temporary variable
            piglet.Move saveVtableAddress = new piglet.Move(vtableAddress, vtableBase);
            labeledStmts.add(convertToLabeledStmt(saveVtableAddress));
            
            // add all procedure addresses to the vtable.
            classDecl.generateVirtualTable(labeledStmts, new piglet.TempExp(vtableAddress));
            
            // Add the vtable address to the vtable_list
            piglet.HStore saveAddressToList = new piglet.HStore(new piglet.TempExp(vtableList), classDecl.classIndex * 4, new piglet.TempExp(vtableAddress));
            labeledStmts.add(convertToLabeledStmt(saveAddressToList));
        }
        
        // Add MainClass.main() code now
        for (LabeledStmt labeledStmt: getMain().getPigletStmts(tempIndex)) {
            labeledStmts.add(labeledStmt);
        }
        
        return new piglet.Program(labeledStmts, procedures);
    }
    
    public Integer ClassDecl.classIndex = -1;
    
    // Assign index to classes which have a method declared in their inheritance chain.
    syn lazy Integer Program.setupClassIndices() {
        int classCount = 0;
        for (ClassDecl classDecl: getDeclsList()) {
            
            // This class has no methods at all? Don't bother generating a vtable.
            if (classDecl.getMethodCountInClassChain() == 0) {
                continue;
            }
            
            // TODO: ignore classes which don't override or add new methods.
            // No need to waste more memory, if we won't change or add an entry in the table.
            //if (classDecl.hasSuperClass() && classDecl.getMethodsList().getNumChild() == 0 /* || classDecl.hasNoOverriddenMethods()*/) {
                // TODO: Use the vtable of the parent class
                // classDecl.vtable = superClass().vtable;
                // continue;
            //}
            
            classDecl.classIndex = classCount;
            classCount++;
        }
        
        return classCount;
    }
    
    /*
     * DECLARATIONS
     */
    
    public piglet.Temp TypedVar.temp = null;
    // TODO throw exception if temp is still null!
    syn piglet.Temp TypedVar.temp() = temp;
     
    syn lazy piglet.List<piglet.LabeledStmt> MainClass.getPigletStmts(int tempIndex) {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // Assign local vars a temporary identifier
        for (TypedVar localVar: getLocalVarsList()) {
            localVar.temp = new piglet.Temp(tempIndex++);
        }
        
        // Translate statments
        for (Stmt stmt: getStmtsList()) {
            for (piglet.LabeledStmt pigletStmt: stmt.toPiglet()) {
                labeledStmts.add(pigletStmt);
            }
        }
        
        return labeledStmts;
    }
    
    public int TypedVar.fieldOffset = 0;
    syn Integer ClassDecl.setupClassFields(int offset) {
        // First setup fields of superclass before my own.
        if (superClass() != null)
            offset = superClass().setupClassFields(offset);
        
        // Assign proper offsets to my own fields.    
        for (TypedVar field: getFieldsList()) {
            field.fieldOffset = offset;
            offset += 4;
        }
        
        return offset;
    }
    
    // Index into vtable of the class.
    public int MethodDecl.methodIndex = -1;
    syn Integer ClassDecl.setupMethods(int index) {
        // First set indices of methods of super class.
        if (superClass() != null)
            index = superClass().setupMethods(index);
        
        // Walk through my methods and set the index
        for (MethodDecl method: getMethodsList()) {
            // If we're overriding a method, set it to the index of the superclass' method.
            if (method.overriddenMethod() != null) {
                method.methodIndex = method.overriddenMethod().methodIndex;
                continue;
            }
            
            // This is the |index|th method in the class hierachy.
            method.methodIndex = index;
            index++;
        }
        return index;
    }
    
    // Add all methods to the methods list.
    // Replace methods in the list which get overridden.
    syn lazy ArrayList<MethodDecl> ClassDecl.collectMethods(ArrayList<MethodDecl> methods) {
        // Add methods of superclass first.
        if (superClass() != null)
            superClass().collectMethods(methods);
        
        for (MethodDecl method: getMethodsList()) {
            // This method overrides some other method.
            if (method.overriddenMethod() != null) {
                // Replace method on that index with our overridden one!
                methods.set(method.overriddenMethod().methodIndex, method);
            }
            // Add this method to the list at the corresponding methodIndex position
            else {
                methods.add(method);
            }
        }
        
        return methods;
    }
    
    // Store addresses of methods to vtable
    syn lazy piglet.List<piglet.LabeledStmt> ClassDecl.generateVirtualTable(piglet.List<piglet.LabeledStmt> labeledStmts, piglet.Exp vtableBase) {
        ArrayList<MethodDecl> methods = new ArrayList<MethodDecl>();
        
        // Add all methods to the list.
        // This inserts the overriding methods at the index of the overridden method of the super class. 
        collectMethods(methods);
        
        // Run through all methods and add the address of the procedure to the vtable
        for (MethodDecl method: methods) {
            piglet.LabelExp methodLabel = new piglet.LabelExp(method.getPigletLabel());
            piglet.HStore storeMethodAddress = new piglet.HStore(vtableBase, method.methodIndex * 4, methodLabel);
            labeledStmts.add(convertToLabeledStmt(storeMethodAddress));
        }
        return labeledStmts;
    }
    
    syn lazy piglet.List<piglet.Procedure> ClassDecl.getProcedures() {
        piglet.List<piglet.Procedure> procedures = new piglet.List<piglet.Procedure>();
        
        for (MethodDecl method: getMethodsList()) {
            procedures.add(method.toPiglet());
        }
        
        return procedures;
    }
    
    syn lazy piglet.Procedure MethodDecl.toPiglet() {
        // Assign local vars and parameters a temporary identifier
        // skip param 0 (vtable list)
        // skip param 1 (object reference)
        int i = 2;
        for (TypedVar parameter: getFormalParamsList()) {
            parameter.temp = new piglet.Temp(i++);
        }
        for (TypedVar localVar: getLocalVarsList()) {
            localVar.temp = new piglet.Temp(i++);
        }
        
        // Translate statments
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        for (Stmt stmt: getStmtsList()) {
            for (piglet.LabeledStmt pigletStmt: stmt.toPiglet()) {
                labeledStmts.add(pigletStmt);
            }
        }
        
        piglet.StmtExp body = new piglet.StmtExp(labeledStmts, getRetExp().toPiglet());
        return new piglet.Procedure(getPigletLabel(), getFormalParamsList().getNumChild() + 2, body);
    }
    
    
    
    /*
     * STATEMENTS
     */

    syn lazy piglet.List<piglet.LabeledStmt> Stmt.toPiglet();
    
    eq Block.toPiglet() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // Translate statments
        for (Stmt stmt: getStmtsList()) {
            for (piglet.LabeledStmt pigletStmt: stmt.toPiglet()) {
                labeledStmts.add(pigletStmt);
            }
        }
        return labeledStmts;
    }
    
    public static int If.labelIndex = 0;
    eq If.toPiglet() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // create labels
        piglet.Label elseLabel = new piglet.Label("else_" + labelIndex);
        piglet.Label exitLabel = new piglet.Label("skipelse_" + labelIndex);
        labelIndex++;
        
        // condition including |&&| logic chains
        handleCondition(labeledStmts, elseLabel, getCond(), null);
        
        // True branch
        piglet.List<piglet.LabeledStmt> trueBranchStmts = getTStmt().toPiglet();
        for (piglet.LabeledStmt labeledStmt: trueBranchStmts) {
            labeledStmts.add(labeledStmt);
        }
        
        // Skip to exit (skip else branch after true branch)
        piglet.Jump exitJump = new piglet.Jump(exitLabel);
        labeledStmts.add(convertToLabeledStmt(exitJump));
        
        // Else label
        labeledStmts.add(convertToLabeledStmt(elseLabel, new piglet.Noop()));
        
        // False branch
        piglet.List<piglet.LabeledStmt> falseBranchStmts = getFStmt().toPiglet();
        for (piglet.LabeledStmt labeledStmt: falseBranchStmts) {
            labeledStmts.add(labeledStmt);
        }
        
        // Exit label
        labeledStmts.add(convertToLabeledStmt(exitLabel, new piglet.Noop()));
        
        return labeledStmts;
    }
    
    public static int While.labelIndex = 0;
    eq While.toPiglet() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // create labels
        piglet.Label entryLabel = new piglet.Label("loop_" + labelIndex);
        piglet.Label exitLabel = new piglet.Label("loopexit_" + labelIndex);
        labelIndex++;
        
        // condition including |&&| logic chains
        handleCondition(labeledStmts, exitLabel, getCond(), entryLabel);
        
        // body
        piglet.List<piglet.LabeledStmt> bodyStmts = getBody().toPiglet();
        for (piglet.LabeledStmt labeledStmt: bodyStmts) {
            labeledStmts.add(labeledStmt);
        }
        
        // backedge
        piglet.Jump backJump = new piglet.Jump(entryLabel);
        labeledStmts.add(convertToLabeledStmt(backJump));
        
        // exit label
        labeledStmts.add(convertToLabeledStmt(exitLabel, new piglet.Noop()));
        
        return labeledStmts;
    }
    
    public static int Assign.labelIndex = 0;
    eq Assign.toPiglet() {
        
        // Maybe this is a field of this class.
        int fieldOffset = getName().decl().fieldOffset;
        piglet.Exp thisAddress = new piglet.TempExp(new piglet.Temp(1));
        
        // Get the temporary of the lhs. Might be null, if it's a class field (fieldOffset > 0).
        piglet.Temp lhs = getName().decl().temp();

        // We're having a boolean assignment with a logic chain
        if (getName().type().isSubtypeOf(booleanType()) && getRhs() instanceof And) {
            // Handle logic chains
            piglet.Label falseLabel = new piglet.Label("boolassign_" + labelIndex);
            piglet.Label skipFalseLabel = new piglet.Label("boolassignskip_" + labelIndex);
            labelIndex++;
            
            piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
            handleCondition(labeledStmts, falseLabel, getRhs(), null);
            
            // Assign 1 to the lhs if all conditions were true.
            piglet.Stmt trueMove;
            // This is a class field.
            if (fieldOffset > 0) {
                trueMove = new piglet.HStore(thisAddress, fieldOffset, new piglet.IntLiteral(1));
            // This is a normal local variable.
            } else {
                trueMove = new piglet.Move(lhs, new piglet.IntLiteral(1));
            }
            labeledStmts.add(convertToLabeledStmt(trueMove));
            // Skip setting lhs to 0.
            piglet.Jump skipFalse = new piglet.Jump(skipFalseLabel);
            labeledStmts.add(convertToLabeledStmt(skipFalse));
            
            // Assign 0 to the rhs, if one of the conditions were false.
            piglet.Stmt falseMove;
            // This is a class field.
            if (fieldOffset > 0) {
                falseMove = new piglet.HStore(thisAddress, fieldOffset, new piglet.IntLiteral(0));
            // This is a normal local variable.
            } else {
                falseMove = new piglet.Move(lhs, new piglet.IntLiteral(0));
            }
                            
            labeledStmts.add(convertToLabeledStmt(falseLabel, falseMove));
            labeledStmts.add(convertToLabeledStmt(skipFalseLabel, new piglet.Noop()));
            return labeledStmts;
        }
    
        // Just an ordinary assignment.
        piglet.Exp rhs = getRhs().toPiglet();
        
        // This is a class field. Save the value properly in the instance memory on the heap.
        if (fieldOffset > 0) {
            return convertToLabeledStmts(new piglet.HStore(thisAddress, fieldOffset, rhs));
        }
        
        // This is a normal local variable.
        return convertToLabeledStmts(new piglet.Move(lhs, rhs));
    }
    
    eq Print.toPiglet() {
        return convertToLabeledStmts(new piglet.Print(getExp().toPiglet()));
    }
    
    eq ArrayAssign.toPiglet() {
        piglet.Exp lhs = getName().toPiglet();
        piglet.Exp rhs = getExp().toPiglet();
        piglet.Exp offset = getOffset().toPiglet();
        
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // check at run-time for „index out of bounds “
        // offset > length --> new piglet.Err();
        insertArrayBoundsCheck(labeledStmts, lhs, offset);
        
        //address = lhs + (offset*4)
        piglet.Exp offsetInBytes = new piglet.Times(offset, new piglet.IntLiteral(4));
        piglet.Exp address = new piglet.Plus(lhs, offsetInBytes);
        
        // length in first 4 bytes -> <Offset:Integer> = 4
        labeledStmts.add(convertToLabeledStmt(new piglet.HStore(address, 4, rhs)));
        return labeledStmts;
    }



    /*
     * EXPRESSIONS
     */
     
    syn lazy piglet.Exp Exp.toPiglet();
    
    eq Cmp.toPiglet() {
        return new piglet.Lt(getLeft().toPiglet(), getRight().toPiglet());
    }
    
    eq Add.toPiglet() {
        return new piglet.Plus(getLeft().toPiglet(), getRight().toPiglet());
    }
    eq Sub.toPiglet() {
        return new piglet.Minus(getLeft().toPiglet(), getRight().toPiglet());
    }
    eq Mult.toPiglet() {
        return new piglet.Times(getLeft().toPiglet(), getRight().toPiglet());
    }

    eq Not.toPiglet() {
        // !boolean == boolean < 1
        // 1 < 1 => 0
        // 0 < 1 => 1
        return new piglet.Lt(getExp().toPiglet(), new piglet.IntLiteral(1));
    }

    eq IdentUse.toPiglet() {
        int fieldOffset = decl().fieldOffset;
        // Class field!
        if (fieldOffset > 0) {
            piglet.Exp thisAddress = new piglet.TempExp(new piglet.Temp(1));
            return createCall("GETOBJECTFIELD", thisAddress, new piglet.IntLiteral(fieldOffset));
        }
        // Normal variable.
        else {
            return new piglet.TempExp(decl().temp());
        }
    }

    eq IntLiteral.toPiglet() {
        return new piglet.IntLiteral(getInteger());
    }
    
    eq True.toPiglet() {
        return new piglet.IntLiteral(1);
    }
    
    eq False.toPiglet() {
        return new piglet.IntLiteral(0);
    }
    
    eq ArrayAlloc.toPiglet() {
        // Call ARRAYALLOC procedure
        return createCall("ARRAYALLOC", getSize().toPiglet());
    }
    
    eq ObjAlloc.toPiglet() {
        // Call OBJECTALLOC(vtable_list, classoffset, size) procedure
        // 4 bytes for vtable list
        // 4 bytes for virtual function table
        return createCall("OBJECTALLOC", new piglet.TempExp(new piglet.Temp(0)), new piglet.IntLiteral(decl().classIndex * 4), new piglet.IntLiteral(decl().getTotalNumberOfFields()*4 + 8));
    }
    
    eq ArrayLookup.toPiglet() {
        // Call ARRAYLOOKUP procedure
        return createCall("ARRAYLOOKUP", getExp().toPiglet(), getOffset().toPiglet());
    }
    
    eq ArrayLength.toPiglet() {
        // Call ARRAYLENGTH procedure
        return createCall("ARRAYLENGTH", getExp().toPiglet());
    }
    
    eq MethodCall.toPiglet() {
        piglet.Exp procedureName = new LabelExp(decl().getPigletLabel());
        piglet.List<piglet.Exp> params = new piglet.List<piglet.Exp>();
        
        // first param is reference to vtable list
        params.add(new piglet.TempExp(new piglet.Temp(0)));
        
        // second param is reference to object ("this" in procedure)
        piglet.Call nullCheck = createCall("CHECKNULLADDRESS", getObj().toPiglet());
        params.add(nullCheck); 
        
        // params
        for(Exp arg: getArgsList()) {
            params.add(arg.toPiglet());
        }
        
        return new piglet.Call(procedureName, params); 
    }
    
    eq This.toPiglet() {
        // first param of procedure is reference to object
        return new piglet.TempExp(new piglet.Temp(1));
    }
    
    // Don't add the LHS of the |And| to the collectedStmts list, if it's the first condition in a logic chain.
    public static boolean And.firstCondition = true;
    // Jump to this label, if one of the conditions is false.
    public static piglet.Label And.exitLabel = null;
    // Collect all CJumps and conditions.
    public static piglet.List<piglet.LabeledStmt> And.collectedStmts = null;
    
    eq And.toPiglet() {
        piglet.Exp lhs = getLeft().toPiglet();
        // The first condition in the logic chain is returned right away to add optional labels.
        if (!firstCondition) {
            // If we have a chain of |&&| like if (a && b && c)
            // add the conditions in the right order:
            // Return |a| to the |if| handler, add |b| and add |c|
            // Jump to exit label, if one of the conditions in the chain is false.
	        piglet.CJump shortCircuit = new piglet.CJump(lhs, exitLabel);
	        collectedStmts.add(convertToLabeledStmt(shortCircuit));
        }
        // If there is another |And| following on the right hand side, add the lhs now (see above).
        firstCondition = false;
        
        // Evaluate the right expression
        piglet.Exp rhs = getRight().toPiglet();
        // We already added both sides of the rhs to the collectedStmts List if it's a chained condition.
        if (getRight() instanceof And)
            return lhs;
        
        // Jump to exit label, if one of the conditions in the chain is false.
        piglet.CJump shortCircuit = new piglet.CJump(rhs, exitLabel);
        collectedStmts.add(convertToLabeledStmt(shortCircuit));
        
        // Always return the left condition. It gets handled in the caller.
        return lhs;
    }
    
    
    
    /*
     * HELPERS
     */
     
    syn piglet.List<piglet.LabeledStmt> ASTNode.convertToLabeledStmts(piglet.List<piglet.Stmt> stmts) {
        piglet.List<piglet.LabeledStmt> list = new piglet.List<piglet.LabeledStmt>();
        for (piglet.Stmt stmt: stmts) {
            list.add(new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(), stmt));
        }
        return list;
    }
    
    syn piglet.List<piglet.LabeledStmt> ASTNode.convertToLabeledStmts(piglet.Stmt stmt) {
        piglet.List<piglet.LabeledStmt> list = new piglet.List<piglet.LabeledStmt>();
        list.add(new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(), stmt));
        return list;
    }
    
    syn piglet.LabeledStmt ASTNode.convertToLabeledStmt(piglet.Stmt stmt) {
        return new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(), stmt);
    }
    
    syn piglet.LabeledStmt ASTNode.convertToLabeledStmt(piglet.Label label, piglet.Stmt stmt) {
        return new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(label), stmt);
    }
    
    public void ASTNode.handleCondition(piglet.List<piglet.LabeledStmt> labeledStmts, piglet.Label exitLabel, Exp expression, piglet.Label entryLabel) {
        // Setup |&&| decomposition
        And.firstCondition = true;
        And.exitLabel = exitLabel;
        And.collectedStmts = new piglet.List<piglet.LabeledStmt>();
        // Get condition and collect additional chained conditions in And.collectedStmts
        piglet.Exp condition = expression.toPiglet();
        // Add the first condition
        piglet.CJump jump = new piglet.CJump(condition, exitLabel);
        if (entryLabel == null) {
            labeledStmts.add(convertToLabeledStmt(jump));
        }
        else {
            labeledStmts.add(convertToLabeledStmt(entryLabel, jump));
        }
        // See if there were any |&&|s in the logic chain. Add the jumps as well.
        // Prepare jastadd List..
        And.collectedStmts.getNumChild();
        for (piglet.LabeledStmt labeledStmt: And.collectedStmts) {
            labeledStmts.add(labeledStmt);
        }
    }
    
    syn lazy piglet.Procedure ASTNode.createObjectFieldAccessProcedure() {
        // Create a procedure 
        piglet.Label label = new piglet.Label("GETOBJECTFIELD");
        int paramCount = 2;
        
        // params
        piglet.Exp obj = new piglet.TempExp(new piglet.Temp(0));
        piglet.Exp offset = new piglet.TempExp(new piglet.Temp(1));
        
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        piglet.Temp fieldValue = new piglet.Temp(2);
        piglet.Plus calcFieldAddress = new piglet.Plus(obj, offset);
        piglet.HLoad loadFieldValue = new piglet.HLoad(fieldValue, calcFieldAddress, 0);
        labeledStmts.add(convertToLabeledStmt(loadFieldValue));
        
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, new piglet.TempExp(fieldValue));
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    syn lazy piglet.Procedure ASTNode.createObjNullCheckProcedure() {
        // Create a procedure 
        piglet.Label label = new piglet.Label("CHECKNULLADDRESS");
        int paramCount = 1;
        
        // params
        piglet.Exp obj = new piglet.TempExp(new piglet.Temp(0));
        
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        piglet.Label returnLabel = new piglet.Label("nullcheck_ok");
        
        // if (obj < 1)
        piglet.Exp condition = new piglet.Lt(obj, new piglet.IntLiteral(1));
        piglet.CJump okJump = new piglet.CJump(condition, returnLabel);
        labeledStmts.add(convertToLabeledStmt(okJump));
        
        // Null pointer!!
        labeledStmts.add(convertToLabeledStmt(new piglet.Err()));
        
        labeledStmts.add(convertToLabeledStmt(returnLabel, new piglet.Noop()));
        
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, obj);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    syn lazy piglet.Procedure ASTNode.createArrayAllocProcedure() {
        // Create a procedure 
        piglet.Label label = new piglet.Label("ARRAYALLOC");
        int paramCount = 1;
        
        // params
        piglet.Exp size = new piglet.TempExp(new piglet.Temp(0)); // first param
        
        // calculate size in byte. first 4 bytes are reserved for length
        // sizeInBytes = size*4 + 4
        piglet.Exp sizeInBytes = new piglet.Times(size, new piglet.IntLiteral(4));
        piglet.Exp sizeInByteWithLength = new piglet.Plus(sizeInBytes, new piglet.IntLiteral(4));
        
        // Statements
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        // First allocate enough memory on the heap
        piglet.Temp address = new piglet.Temp(1);
        piglet.Move saveAddress = new Move(address, new piglet.HAlloc(sizeInByteWithLength));
        labeledStmts.add(convertToLabeledStmt(saveAddress));
        
        // Save array base, so we can return it later from the procedure.
        piglet.Exp addressExp = new TempExp(address);
        
        // store length as first 4 bytes
        piglet.HStore storeSize = new piglet.HStore(addressExp, 0, size);
        labeledStmts.add(convertToLabeledStmt(storeSize));
        
        // Offset of 4 because of the array size as first element.
        insertInitializeWithZero(labeledStmts, address, sizeInBytes, 4, 2);
       
        // return address of allocated memory block
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, addressExp);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    syn lazy piglet.Procedure ASTNode.createArrayLookupProcedure() {
        piglet.Label label = new piglet.Label("ARRAYLOOKUP");
        int paramCount = 2;
        
        // params
        piglet.Exp arrayAddress = new TempExp(new piglet.Temp(0)); // first param
        piglet.Exp offset = new TempExp(new piglet.Temp(1)); // second param
        
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
          
        // check at run-time for „index out of bounds “
        // offset > length --> new piglet.Err();
        insertArrayBoundsCheck(labeledStmts, arrayAddress, offset);
        
        // address = arrayAdress + 4 + (offset*4)
        piglet.Exp offsetInBytes = new piglet.Times(offset, new piglet.IntLiteral(4));
        piglet.Exp address = new piglet.Plus(arrayAddress, offsetInBytes);
        
        // load result into temp, which will be returned
        piglet.Temp temp = new piglet.Temp(2);
        piglet.HLoad hload = new piglet.HLoad(temp, address, 4); // length offset = 4 bytes
        labeledStmts.add(convertToLabeledStmt(hload));
        
        // return temp with value at adress
        piglet.Exp retExp = new TempExp(temp);
        
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, retExp);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    syn lazy piglet.Procedure ASTNode.createArrayLengthProcedure() {
        piglet.Label label = new piglet.Label("ARRAYLENGTH");
        int paramCount = 1;
        
        // params
        piglet.Exp address = new TempExp(new piglet.Temp(0)); // first param
        
        // Statements  
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        // load length into temp, which will be returned
        piglet.Temp length = new piglet.Temp(1);
        piglet.HLoad hload = new piglet.HLoad(length, address, 0);
        labeledStmts.add(convertToLabeledStmt(hload));
        
        // return length
        piglet.Exp retExp = new TempExp(length);
        
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, retExp);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    syn lazy piglet.Procedure ASTNode.createObjectAllocProcedure() {
        piglet.Label label = new piglet.Label("OBJECTALLOC");
        int paramCount = 1;
        
        // params
        piglet.Exp vtableList = new piglet.TempExp(new piglet.Temp(0));
        piglet.Exp classOffset = new piglet.TempExp(new piglet.Temp(1));
        piglet.Exp size = new piglet.TempExp(new piglet.Temp(2));
        
        // Statements  
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        piglet.Temp address = new piglet.Temp(3);
        piglet.Move saveAddress = new Move(address, new piglet.HAlloc(size));
        labeledStmts.add(convertToLabeledStmt(saveAddress));
        
        insertInitializeWithZero(labeledStmts, address, size, 0, 2);
        
        // Get virtual function table address
        // vtableList[classIndex]
        piglet.Temp vtable = new piglet.Temp(4);
        piglet.Exp calcListOffset = new piglet.Plus(vtableList, classOffset);
        piglet.HLoad vtableAddress = new piglet.HLoad(vtable, calcListOffset, 0); 
        
        // save virtual function table address
        piglet.TempExp addressExp = new piglet.TempExp(address);
        piglet.HStore addVTableAddress = new piglet.HStore(addressExp, 0, new piglet.TempExp(vtable));
        labeledStmts.add(convertToLabeledStmt(addVTableAddress));
        
        // return address of allocated block
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, addressExp);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    public void ASTNode.insertArrayBoundsCheck(piglet.List<piglet.LabeledStmt> labeledStmts, piglet.Exp arrayBase, piglet.Exp index) {
        piglet.Label errorLabel = new piglet.Label("arraybounds_error");
        piglet.Label returnLabel = new piglet.Label("arraybounds_ok");
        
        // Get array size
        piglet.Temp arraySize = new piglet.Temp(2);
        piglet.HLoad loadSize = new piglet.HLoad(arraySize, arrayBase, 0);
        labeledStmts.add(convertToLabeledStmt(loadSize));
        
        // if (index < arraySize)
        piglet.Exp condition = new piglet.Lt(index, new piglet.TempExp(arraySize)); 
        piglet.CJump sizeCheck = new piglet.CJump(condition, errorLabel);
        labeledStmts.add(convertToLabeledStmt(sizeCheck));
        
        // if (-1 < index)
        piglet.Minus minusOne = new piglet.Minus(new piglet.IntLiteral(0), new piglet.IntLiteral(1));
        condition = new piglet.Lt(minusOne, index);
        sizeCheck = new piglet.CJump(condition, errorLabel);
        labeledStmts.add(convertToLabeledStmt(sizeCheck));
        
        // DON'T ERROR. All fine.
        piglet.Jump okJump = new piglet.Jump(returnLabel);
        labeledStmts.add(convertToLabeledStmt(okJump));
        
        // Array out of bounds!
        piglet.Err error = new piglet.Err();
        labeledStmts.add(convertToLabeledStmt(errorLabel, error));
        
        labeledStmts.add(convertToLabeledStmt(returnLabel, new piglet.Noop()));
    }
    
    syn lazy piglet.Label MethodDecl.getPigletLabel() {
        return new piglet.Label(containingClass().getIdent() + "_" + getIdent());
    }
    
    public piglet.Call ASTNode.createCall(String name, piglet.Exp... params) {
        piglet.Exp procedureLabel = new LabelExp(new Label(name));
        
        piglet.List<piglet.Exp> paramsList = new piglet.List<piglet.Exp>();
        for(piglet.Exp param: params) {
	        paramsList.add(param);
        }
        
        return new piglet.Call(procedureLabel, paramsList); 
    }
    
    public void ASTNode.insertInitializeWithZero(piglet.List<piglet.LabeledStmt> labeledStmts, piglet.Temp baseAddress, piglet.Exp sizeInBytes, int offset, int firstTempNr) {
        // create labels
        piglet.Label entryLabel = new piglet.Label("insert_zero_condition");
        piglet.Label exitLabel = new piglet.Label("insert_zero_exit");
        
        piglet.TempExp baseAddressExp = new piglet.TempExp(baseAddress);
 
        // currentAddress = address;
        piglet.Temp currentAddress = new piglet.Temp(firstTempNr++);
        piglet.Move setStartAddress = new piglet.Move(currentAddress, baseAddressExp);
        labeledStmts.add(convertToLabeledStmt(setStartAddress));
        
        piglet.Temp endAddress = new piglet.Temp(firstTempNr++);
        // address + size * 4
        piglet.Plus calcEndAddress = new piglet.Plus(baseAddressExp, sizeInBytes);
        // endAddress = address + size * 4;
        piglet.Move storeEndAddress = new piglet.Move(endAddress, calcEndAddress);
        labeledStmts.add(convertToLabeledStmt(storeEndAddress));
        
        // for (; currentAddress < endAddress; currentAddress += 4)
        piglet.CJump condition = new piglet.CJump(new piglet.Lt(new piglet.TempExp(currentAddress), new piglet.TempExp(endAddress)), exitLabel);
        labeledStmts.add(convertToLabeledStmt(entryLabel, condition));
        
        // currentAddress = 0;
        piglet.HStore initBlock = new piglet.HStore(new piglet.TempExp(currentAddress), offset, new piglet.IntLiteral(0));
        labeledStmts.add(convertToLabeledStmt(initBlock));

        // currentAddress += 4;
        piglet.Plus calcNextAddress = new piglet.Plus(new piglet.TempExp(currentAddress), new piglet.IntLiteral(4));
        piglet.Move storeNextAddress = new piglet.Move(currentAddress, calcNextAddress);
        labeledStmts.add(convertToLabeledStmt(storeNextAddress));
        
        // backedge
        piglet.Jump backJump = new piglet.Jump(entryLabel);
        labeledStmts.add(convertToLabeledStmt(backJump));
        
        // exit label
        labeledStmts.add(convertToLabeledStmt(exitLabel, new piglet.Noop()));
    }
}