import piglet.*;

aspect PigletASTBuilder {
    // TODO objects (virtual tables, fields)
    // TODO Translate classes
    
    syn lazy piglet.Program Program.toPiglet() {
        piglet.List<piglet.Procedure> procedures = new piglet.List<piglet.Procedure>();
        
        // helper procedures
        procedures.add(createArrayAllocProcedure());
        procedures.add(createArrayLookupProcedure());
        procedures.add(createArrayLengthProcedure());
        procedures.add(createObjNullCheckProcedure());
        procedures.add(createObjectAllocProcedure());
        
        for (ClassDecl classDecl: getDeclsList()) {
            for(piglet.Procedure procedure: classDecl.getProcedures()) {
                procedures.add(procedure);
            }
        }
        
        return new piglet.Program(getMain().getPigletStmts(), procedures);
    }
    
    syn lazy Integer ClassDecl.getTotalNumberOfFields() {
        int numFieldsOfSuperclass = 0;
        if (superClass() != null)
            numFieldsOfSuperclass = superClass().getTotalNumberOfFields();
        return getFieldsList().getNumChild() + numFieldsOfSuperclass;
    }
    
    
    /*
     * DECLARATIONS
     */
    
    public piglet.Temp TypedVar.temp = null;
    // TODO throw exception if temp is still null!
    syn piglet.Temp TypedVar.temp() = temp;
     
    syn lazy piglet.List<piglet.LabeledStmt> MainClass.getPigletStmts() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // Assign local vars a temporary identifier
        int i = 0;
        for (TypedVar localVar: getLocalVarsList()) {
            localVar.temp = new piglet.Temp(i++);
        }
        
        // Translate statments
        for (Stmt stmt: getStmtsList()) {
            for (piglet.LabeledStmt pigletStmt: stmt.toPiglet()) {
                labeledStmts.add(pigletStmt);
            }
        }
        
        return labeledStmts;
    }
    
    syn lazy piglet.List<piglet.LabeledStmt> ClassDecl.getPigletStmts() {
        // TODO initialize newly allocated fields with zero.
        return null;
    }
    
    syn lazy piglet.List<piglet.Procedure> ClassDecl.getProcedures() {
        piglet.List<piglet.Procedure> procedures = new piglet.List<piglet.Procedure>();
        
        for (MethodDecl method: getMethodsList()) {
            procedures.add(method.toPiglet());
        }
        
        return procedures;
    }
    
    syn lazy piglet.Procedure MethodDecl.toPiglet() {
        // Assign local vars and parameters a temporary identifier
        // skip param 0 (object reference)
        int i = 1;
        for (TypedVar parameter: getFormalParamsList()) {
            parameter.temp = new piglet.Temp(i++);
        }
        for (TypedVar localVar: getLocalVarsList()) {
            localVar.temp = new piglet.Temp(i++);
        }
        
        // Translate statments
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        for (Stmt stmt: getStmtsList()) {
            for (piglet.LabeledStmt pigletStmt: stmt.toPiglet()) {
                labeledStmts.add(pigletStmt);
            }
        }
        
        piglet.StmtExp body = new piglet.StmtExp(labeledStmts, getRetExp().toPiglet());
        return new piglet.Procedure(getPigletLabel(), getFormalParamsList().getNumChild() + 1, body);
    }
    
    
    
    /*
     * STATEMENTS
     */

    syn lazy piglet.List<piglet.LabeledStmt> Stmt.toPiglet();
    
    eq Block.toPiglet() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // Translate statments
        for (Stmt stmt: getStmtsList()) {
            for (piglet.LabeledStmt pigletStmt: stmt.toPiglet()) {
                labeledStmts.add(pigletStmt);
            }
        }
        return labeledStmts;
    }
    
    public static int If.labelIndex = 0;
    eq If.toPiglet() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // create labels
        piglet.Label elseLabel = new piglet.Label("else_" + labelIndex);
        piglet.Label exitLabel = new piglet.Label("skipelse_" + labelIndex);
        labelIndex++;
        
        // condition including |&&| logic chains
        handleCondition(labeledStmts, elseLabel, getCond(), null);
        
        // True branch
        piglet.List<piglet.LabeledStmt> trueBranchStmts = getTStmt().toPiglet();
        for (piglet.LabeledStmt labeledStmt: trueBranchStmts) {
            labeledStmts.add(labeledStmt);
        }
        
        // Skip to exit (skip else branch after true branch)
        piglet.Jump exitJump = new piglet.Jump(exitLabel);
        labeledStmts.add(convertToLabeledStmt(exitJump));
        
        // Else label
        labeledStmts.add(convertToLabeledStmt(elseLabel, new piglet.Noop()));
        
        // False branch
        piglet.List<piglet.LabeledStmt> falseBranchStmts = getFStmt().toPiglet();
        for (piglet.LabeledStmt labeledStmt: falseBranchStmts) {
            labeledStmts.add(labeledStmt);
        }
        
        // Exit label
        labeledStmts.add(convertToLabeledStmt(exitLabel, new piglet.Noop()));
        
        return labeledStmts;
    }
    
    public static int While.labelIndex = 0;
    eq While.toPiglet() {
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        
        // create labels
        piglet.Label entryLabel = new piglet.Label("loop_" + labelIndex);
        piglet.Label exitLabel = new piglet.Label("loopexit_" + labelIndex);
        labelIndex++;
        
        // condition including |&&| logic chains
        handleCondition(labeledStmts, exitLabel, getCond(), entryLabel);
        
        // body
        piglet.List<piglet.LabeledStmt> bodyStmts = getBody().toPiglet();
        for (piglet.LabeledStmt labeledStmt: bodyStmts) {
            labeledStmts.add(labeledStmt);
        }
        
        // backedge
        piglet.Jump backJump = new piglet.Jump(entryLabel);
        labeledStmts.add(convertToLabeledStmt(backJump));
        
        // exit label
        labeledStmts.add(convertToLabeledStmt(exitLabel, new piglet.Noop()));
        
        return labeledStmts;
    }
    
    public static int Assign.labelIndex = 0;
    eq Assign.toPiglet() {
        piglet.Temp lhs = getName().decl().temp();

        // We're having a boolean assignment with a logic chain
        if (getName().type().isSubtypeOf(booleanType()) && getRhs() instanceof And) {
            // Handle logic chains
            piglet.Label falseLabel = new piglet.Label("boolassign_" + labelIndex);
            piglet.Label skipFalseLabel = new piglet.Label("boolassignskip_" + labelIndex);
            labelIndex++;
            
            piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
            handleCondition(labeledStmts, falseLabel, getRhs(), null);
            
            // Assign 1 to the lhs if all conditions were true.
            piglet.Move trueMove = new piglet.Move(lhs, new piglet.IntLiteral(1));
            labeledStmts.add(convertToLabeledStmt(trueMove));
            // Skip setting lhs to 0.
            piglet.Jump skipFalse = new piglet.Jump(skipFalseLabel);
            labeledStmts.add(convertToLabeledStmt(skipFalse));
            
            // Assign 0 to the rhs, if one of the conditions were false.
            piglet.Move falseMove = new piglet.Move(lhs, new piglet.IntLiteral(0));
            labeledStmts.add(convertToLabeledStmt(falseLabel, falseMove));
            labeledStmts.add(convertToLabeledStmt(skipFalseLabel, new piglet.Noop()));
            return labeledStmts;
        }
    
        // Just an ordinary assignment.
        piglet.Exp rhs = getRhs().toPiglet();
        return convertToLabeledStmts(new piglet.Move(lhs, rhs));
    }
    
    eq Print.toPiglet() {
        return convertToLabeledStmts(new piglet.Print(getExp().toPiglet()));
    }
    
    eq ArrayAssign.toPiglet() {
        piglet.Exp lhs = getName().toPiglet();
        piglet.Exp rhs = getExp().toPiglet();
        piglet.Exp offset = getOffset().toPiglet();
        
        // TODO check at run-time for „index out of bounds “
        // offset > length --> new piglet.Err();
        
        //address = lhs + (offset*4)
        piglet.Exp offsetInBytes = new piglet.Times(offset, new piglet.IntLiteral(4));
        piglet.Exp address = new piglet.Plus(lhs, offsetInBytes);
        
        // length in first 4 bytes -> <Offset:Integer> = 4
        return convertToLabeledStmts(new piglet.HStore(address, 4, rhs));
    }



    /*
     * EXPRESSIONS
     */
     
    syn lazy piglet.Exp Exp.toPiglet();
    
    eq Cmp.toPiglet() {
        return new piglet.Lt(getLeft().toPiglet(), getRight().toPiglet());
    }
    
    eq Add.toPiglet() {
        return new piglet.Plus(getLeft().toPiglet(), getRight().toPiglet());
    }
    eq Sub.toPiglet() {
        return new piglet.Minus(getLeft().toPiglet(), getRight().toPiglet());
    }
    eq Mult.toPiglet() {
        return new piglet.Times(getLeft().toPiglet(), getRight().toPiglet());
    }

    eq Not.toPiglet() {
        // !boolean == boolean < 1
        // 1 < 1 => 0
        // 0 < 1 => 1
        return new piglet.Lt(getExp().toPiglet(), new piglet.IntLiteral(1));
    }

    eq IdentUse.toPiglet() {
        return new piglet.TempExp(decl().temp());
    }

    eq IntLiteral.toPiglet() {
        return new piglet.IntLiteral(getInteger());
    }
    
    eq True.toPiglet() {
        return new piglet.IntLiteral(1);
    }
    
    eq False.toPiglet() {
        return new piglet.IntLiteral(0);
    }
    
    eq ArrayAlloc.toPiglet() {
        // Call ARRAYALLOC procedure
        return createCall("ARRAYALLOC", getSize().toPiglet());
    }
    
    eq ObjAlloc.toPiglet() {
        // Call OBJECTALLOC procedure
        // 4 bytes for virtual function table
        return createCall("OBJECTALLOC", new piglet.IntLiteral(decl().getTotalNumberOfFields()*4 + 4));
    }
    
    eq ArrayLookup.toPiglet() {
        // Call ARRAYLOOKUP procedure
        return createCall("ARRAYLOOKUP", getExp().toPiglet(), getOffset().toPiglet());
    }
    
    eq ArrayLength.toPiglet() {
        // Call ARRAYLENGTH procedure
        return createCall("ARRAYLENGTH", getExp().toPiglet());
    }
    
    eq MethodCall.toPiglet() {
        piglet.Exp procedureName = new LabelExp(decl().getPigletLabel());
        piglet.List<piglet.Exp> params = new piglet.List<piglet.Exp>();
        
        // first param is reference to object ("this" in procedure)
        piglet.Call nullCheck = createCall("CHECKNULLADDRESS", getObj().toPiglet());
        params.add(nullCheck); 
        
        // params
        for(Exp arg: getArgsList()) {
            params.add(arg.toPiglet());
        }
        
        return new piglet.Call(procedureName, params); 
    }
    
    eq This.toPiglet() {
        // first param of procedure is reference to object
        return new piglet.TempExp(new piglet.Temp(0));
    }
    
    // Don't add the LHS of the |And| to the collectedStmts list, if it's the first condition in a logic chain.
    public static boolean And.firstCondition = true;
    // Jump to this label, if one of the conditions is false.
    public static piglet.Label And.exitLabel = null;
    // Collect all CJumps and conditions.
    public static piglet.List<piglet.LabeledStmt> And.collectedStmts = null;
    
    eq And.toPiglet() {
        piglet.Exp lhs = getLeft().toPiglet();
        // The first condition in the logic chain is returned right away to add optional labels.
        if (!firstCondition) {
            // If we have a chain of |&&| like if (a && b && c)
            // add the conditions in the right order:
            // Return |a| to the |if| handler, add |b| and add |c|
            // Jump to exit label, if one of the conditions in the chain is false.
	        piglet.CJump shortCircuit = new piglet.CJump(lhs, exitLabel);
	        collectedStmts.add(convertToLabeledStmt(shortCircuit));
        }
        // If there is another |And| following on the right hand side, add the lhs now (see above).
        firstCondition = false;
        
        // Evaluate the right expression
        piglet.Exp rhs = getRight().toPiglet();
        // We already added both sides of the rhs to the collectedStmts List if it's a chained condition.
        if (getRight() instanceof And)
            return lhs;
        
        // Jump to exit label, if one of the conditions in the chain is false.
        piglet.CJump shortCircuit = new piglet.CJump(rhs, exitLabel);
        collectedStmts.add(convertToLabeledStmt(shortCircuit));
        
        // Always return the left condition. It gets handled in the caller.
        return lhs;
    }
    
    
    
    /*
     * HELPERS
     */
     
    syn piglet.List<piglet.LabeledStmt> ASTNode.convertToLabeledStmts(piglet.List<piglet.Stmt> stmts) {
        piglet.List<piglet.LabeledStmt> list = new piglet.List<piglet.LabeledStmt>();
        for (piglet.Stmt stmt: stmts) {
            list.add(new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(), stmt));
        }
        return list;
    }
    
    syn piglet.List<piglet.LabeledStmt> ASTNode.convertToLabeledStmts(piglet.Stmt stmt) {
        piglet.List<piglet.LabeledStmt> list = new piglet.List<piglet.LabeledStmt>();
        list.add(new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(), stmt));
        return list;
    }
    
    syn piglet.LabeledStmt ASTNode.convertToLabeledStmt(piglet.Stmt stmt) {
        return new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(), stmt);
    }
    
    syn piglet.LabeledStmt ASTNode.convertToLabeledStmt(piglet.Label label, piglet.Stmt stmt) {
        return new piglet.LabeledStmt(new piglet.Opt<piglet.Label>(label), stmt);
    }
    
    public void ASTNode.handleCondition(piglet.List<piglet.LabeledStmt> labeledStmts, piglet.Label exitLabel, Exp expression, piglet.Label entryLabel) {
        // Setup |&&| decomposition
        And.firstCondition = true;
        And.exitLabel = exitLabel;
        And.collectedStmts = new piglet.List<piglet.LabeledStmt>();
        // Get condition and collect additional chained conditions in And.collectedStmts
        piglet.Exp condition = expression.toPiglet();
        // Add the first condition
        piglet.CJump jump = new piglet.CJump(condition, exitLabel);
        if (entryLabel == null) {
            labeledStmts.add(convertToLabeledStmt(jump));
        }
        else {
            labeledStmts.add(convertToLabeledStmt(entryLabel, jump));
        }
        // See if there were any |&&|s in the logic chain. Add the jumps as well.
        // Prepare jastadd List..
        And.collectedStmts.getNumChild();
        for (piglet.LabeledStmt labeledStmt: And.collectedStmts) {
            labeledStmts.add(labeledStmt);
        }
    }
    
    syn lazy piglet.Procedure ASTNode.createObjNullCheckProcedure() {
        // Create a procedure 
        piglet.Label label = new piglet.Label("CHECKNULLADDRESS");
        int paramCount = 1;
        
        // params
        piglet.Exp obj = new piglet.TempExp(new piglet.Temp(0));
        
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        piglet.Label returnLabel = new piglet.Label("nullcheck_ok");
        
        // if (obj < 1)
        piglet.Exp condition = new piglet.Lt(obj, new piglet.IntLiteral(1));
        piglet.CJump okJump = new piglet.CJump(condition, returnLabel);
        labeledStmts.add(convertToLabeledStmt(okJump));
        
        // Null pointer!!
        labeledStmts.add(convertToLabeledStmt(new piglet.Err()));
        
        labeledStmts.add(convertToLabeledStmt(returnLabel, new piglet.Noop()));
        
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, obj);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    syn lazy piglet.Procedure ASTNode.createArrayAllocProcedure() {
        // Create a procedure 
        piglet.Label label = new piglet.Label("ARRAYALLOC");
        int paramCount = 1;
        
        // params
        piglet.Exp size = new piglet.TempExp(new piglet.Temp(0)); // first param
        
        // calculate size in byte. first 4 bytes are reserved for length
        // sizeInBytes = size*4 + 4
        piglet.Exp sizeInBytes = new piglet.Times(size, new piglet.IntLiteral(4));
        piglet.Exp sizeInByteWithLength = new piglet.Plus(sizeInBytes, new piglet.IntLiteral(4));
        
        // Statements
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        // First allocate enough memory on the heap
        piglet.Temp address = new piglet.Temp(1);
        piglet.Move saveAddress = new Move(address, new piglet.HAlloc(sizeInByteWithLength));
        labeledStmts.add(convertToLabeledStmt(saveAddress));
        
        // Save array base, so we can return it later from the procedure.
        piglet.Exp addressExp = new TempExp(address);
        
        // store length as first 4 bytes
        piglet.HStore storeSize = new piglet.HStore(addressExp, 0, size);
        labeledStmts.add(convertToLabeledStmt(storeSize));
        
        // Offset of 4 because of the array size as first element.
        insertInitializeWithZero(labeledStmts, address, sizeInBytes, 4, 2);
       
        // return address of allocated memory block
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, addressExp);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    syn lazy piglet.Procedure ASTNode.createArrayLookupProcedure() {
        piglet.Label label = new piglet.Label("ARRAYLOOKUP");
        int paramCount = 2;
        
        // params
        piglet.Exp arrayAddress = new TempExp(new piglet.Temp(0)); // first param
        piglet.Exp offset = new TempExp(new piglet.Temp(1)); // second param
        
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
          
        // check at run-time for „index out of bounds “
        // offset > length --> new piglet.Err();
        insertArrayBoundsCheck(labeledStmts, arrayAddress, offset);
        
        // address = arrayAdress + 4 + (offset*4)
        piglet.Exp offsetInBytes = new piglet.Times(offset, new piglet.IntLiteral(4));
        piglet.Exp address = new piglet.Plus(arrayAddress, offsetInBytes);
        
        // load result into temp, which will be returned
        piglet.Temp temp = new piglet.Temp(2);
        piglet.HLoad hload = new piglet.HLoad(temp, address, 4); // length offset = 4 bytes
        labeledStmts.add(convertToLabeledStmt(hload));
        
        // return temp with value at adress
        piglet.Exp retExp = new TempExp(temp);
        
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, retExp);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    syn lazy piglet.Procedure ASTNode.createArrayLengthProcedure() {
        piglet.Label label = new piglet.Label("ARRAYLENGTH");
        int paramCount = 1;
        
        // params
        piglet.Exp address = new TempExp(new piglet.Temp(0)); // first param
        
        // Statements  
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        // load length into temp, which will be returned
        piglet.Temp length = new piglet.Temp(1);
        piglet.HLoad hload = new piglet.HLoad(length, address, 0);
        labeledStmts.add(convertToLabeledStmt(hload));
        
        // return length
        piglet.Exp retExp = new TempExp(length);
        
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, retExp);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    syn lazy piglet.Procedure ASTNode.createObjectAllocProcedure() {
        piglet.Label label = new piglet.Label("OBJECTALLOC");
        int paramCount = 1;
        
        // params
        piglet.Exp size = new TempExp(new piglet.Temp(0)); // first param
        
        // Statements  
        piglet.List<piglet.LabeledStmt> labeledStmts = new piglet.List<piglet.LabeledStmt>();
        piglet.Temp address = new piglet.Temp(1);
        piglet.Move saveAddress = new Move(address, new piglet.HAlloc(size));
        labeledStmts.add(convertToLabeledStmt(saveAddress));
        
        insertInitializeWithZero(labeledStmts, address, size, 0, 2);
        
        // add virtual function table address
        piglet.TempExp addressExp = new piglet.TempExp(address);
        piglet.HStore addVTableAddress = new piglet.HStore(addressExp, 0, new piglet.IntLiteral(1337)); // FIXME
        labeledStmts.add(convertToLabeledStmt(addVTableAddress));
        
        // return address of allocated block
        piglet.StmtExp stmtsRet = new StmtExp(labeledStmts, addressExp);
        return new piglet.Procedure(label, paramCount, stmtsRet);
    }
    
    public void ASTNode.insertArrayBoundsCheck(piglet.List<piglet.LabeledStmt> labeledStmts, piglet.Exp arrayBase, piglet.Exp index) {
        piglet.Label errorLabel = new piglet.Label("arraybounds_error");
        piglet.Label returnLabel = new piglet.Label("arraybounds_ok");
        
        // Get array size
        piglet.Temp arraySize = new piglet.Temp(2);
        piglet.HLoad loadSize = new piglet.HLoad(arraySize, arrayBase, 0);
        labeledStmts.add(convertToLabeledStmt(loadSize));
        
        // if (index < arraySize)
        piglet.Exp condition = new piglet.Lt(index, new piglet.TempExp(arraySize)); 
        piglet.CJump sizeCheck = new piglet.CJump(condition, errorLabel);
        labeledStmts.add(convertToLabeledStmt(sizeCheck));
        
        // if (-1 < index)
        piglet.Minus minusOne = new piglet.Minus(new piglet.IntLiteral(0), new piglet.IntLiteral(1));
        condition = new piglet.Lt(minusOne, index);
        sizeCheck = new piglet.CJump(condition, errorLabel);
        labeledStmts.add(convertToLabeledStmt(sizeCheck));
        
        // DON'T ERROR. All fine.
        piglet.Jump okJump = new piglet.Jump(returnLabel);
        labeledStmts.add(convertToLabeledStmt(okJump));
        
        // Array out of bounds!
        piglet.Err error = new piglet.Err();
        labeledStmts.add(convertToLabeledStmt(errorLabel, error));
        
        labeledStmts.add(convertToLabeledStmt(returnLabel, new piglet.Noop()));
    }
    
    syn lazy piglet.Label MethodDecl.getPigletLabel() {
        return new piglet.Label(containingClass().getIdent() + "_" + getIdent());
    }
    
    public piglet.Call ASTNode.createCall(String name, piglet.Exp... params) {
        piglet.Exp procedureLabel = new LabelExp(new Label(name));
        
        piglet.List<piglet.Exp> paramsList = new piglet.List<piglet.Exp>();
        for(piglet.Exp param: params) {
	        paramsList.add(param);
        }
        
        return new piglet.Call(procedureLabel, paramsList); 
    }
    
    public void ASTNode.insertInitializeWithZero(piglet.List<piglet.LabeledStmt> labeledStmts, piglet.Temp baseAddress, piglet.Exp sizeInBytes, int offset, int firstTempNr) {
        // create labels
        piglet.Label entryLabel = new piglet.Label("insert_zero_condition");
        piglet.Label exitLabel = new piglet.Label("insert_zero_exit");
        
        piglet.TempExp baseAddressExp = new piglet.TempExp(baseAddress);
 
        // currentAddress = address;
        piglet.Temp currentAddress = new piglet.Temp(firstTempNr++);
        piglet.Move setStartAddress = new piglet.Move(currentAddress, baseAddressExp);
        labeledStmts.add(convertToLabeledStmt(setStartAddress));
        
        piglet.Temp endAddress = new piglet.Temp(firstTempNr++);
        // address + size * 4
        piglet.Plus calcEndAddress = new piglet.Plus(baseAddressExp, sizeInBytes);
        // endAddress = address + size * 4;
        piglet.Move storeEndAddress = new piglet.Move(endAddress, calcEndAddress);
        labeledStmts.add(convertToLabeledStmt(storeEndAddress));
        
        // for (; currentAddress < endAddress; currentAddress += 4)
        piglet.CJump condition = new piglet.CJump(new piglet.Lt(new piglet.TempExp(currentAddress), new piglet.TempExp(endAddress)), exitLabel);
        labeledStmts.add(convertToLabeledStmt(entryLabel, condition));
        
        // currentAddress = 0;
        piglet.HStore initBlock = new piglet.HStore(new piglet.TempExp(currentAddress), offset, new piglet.IntLiteral(0));
        labeledStmts.add(convertToLabeledStmt(initBlock));

        // currentAddress += 4;
        piglet.Plus calcNextAddress = new piglet.Plus(new piglet.TempExp(currentAddress), new piglet.IntLiteral(4));
        piglet.Move storeNextAddress = new piglet.Move(currentAddress, calcNextAddress);
        labeledStmts.add(convertToLabeledStmt(storeNextAddress));
        
        // backedge
        piglet.Jump backJump = new piglet.Jump(entryLabel);
        labeledStmts.add(convertToLabeledStmt(backJump));
        
        // exit label
        labeledStmts.add(convertToLabeledStmt(exitLabel, new piglet.Noop()));
    }
}