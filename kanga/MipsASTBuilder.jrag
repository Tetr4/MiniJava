import java.lang.Math;
import java.util.HashSet;
import java.util.HashMap;
import mips.*;

aspect MipsASTBuilder {
    
    
    private static void Program.reset() {
    }
     
    // Program
    syn lazy mips.Program Program.toMips() {
        // Reset builder state
        reset();
        
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        stmts.add(new Txt());
        stmts.add(new Globl("main"));
        stmts.add(new mips.Label("main"));
        
        // Labeled Statements
        for (LabeledStmt labeledStmt : getStmtsList()) {
            // add all
            for (mips.Stmt stmt : labeledStmt.toMips()) {
                stmts.add(stmt);
            }
        }
        
        // Procedures
        for (Procedure procedure : getProcsList()) {
            // add all
            for (mips.Stmt stmt : procedure.toMips()) {
                stmts.add(stmt);
            }
        }
        
        // Add predefined helpers:
        // _halloc!
        stmts.add(new Txt());
        stmts.add(new Globl("_halloc"));
        stmts.add(new mips.Label("_halloc"));
        stmts.add(new Li(new mips.Reg("v0"), new DecConst(9))); // sbrk (alloc)
        stmts.add(new Syscall());
        stmts.add(new J(new mips.Reg("ra")));
        
        // _print
        stmts.add(new Globl("_print"));
        stmts.add(new mips.Label("_print"));
        stmts.add(new Li(new mips.Reg("v0"), new DecConst(1))); // print int
        stmts.add(new Syscall());
        stmts.add(new La(new mips.Reg("a0"), new IdConst("newl")));
        stmts.add(new Li(new mips.Reg("v0"), new DecConst(4))); // print string
        stmts.add(new Syscall());
        stmts.add(new J(new mips.Reg("ra")));
        
        // _error
        stmts.add(new Globl("_error"));
        stmts.add(new mips.Label("_error"));
        stmts.add(new La(new mips.Reg("a0"), new IdConst("str_er")));
        stmts.add(new Li(new mips.Reg("v0"), new DecConst(4))); // print string
        stmts.add(new Syscall());
        stmts.add(new Li(new mips.Reg("v0"), new DecConst(10))); // exit
        stmts.add(new Syscall());
        
        // newl   
        stmts.add(new Dat());
        stmts.add(new Align(0));
        stmts.add(new mips.Label("newl"));
        stmts.add(new Data(new Asciiz(), new StringData("\\n")));
        
        // str_er
        stmts.add(new mips.Label("str_er"));
        stmts.add(new Data(new Asciiz(), new StringData("ERROR\\n"))); 
        
        return new mips.Program(stmts);
    }
    
    // LabeledStmt
    syn lazy mips.List<mips.Stmt> LabeledStmt.toMips() {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        // Label
        if(hasLabel()) {
            stmts.add(getLabel().toMips());
        }
        
        // Statement
        for (mips.Stmt stmt : getStmt().toMips()) {
            stmts.add(stmt);
        }
        return stmts;
    }
    
    // Procedure
    syn lazy mips.List<mips.Stmt> Procedure.toMips() {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        // globl
        stmts.add(new Txt());
        stmts.add(new Globl(getLabel().getLabel()));
        
        // label
        stmts.add(getLabel().toMips());
        
        // allocate stack space
        // subi $sp, $sp, <stackslots>
        mips.Sub allocateStack = new mips.Sub(new mips.Reg("sp"), new mips.Reg("sp"), new DecConst(getStackSlots()));
        stmts.add(allocateStack);
        
        // Labeled Statements
        for (LabeledStmt labeledStmt : getStmtsList()) {
            // add all
            for (mips.Stmt stmt : labeledStmt.toMips()) {
                stmts.add(stmt);
            }
        }
        
        // free stack space
        // addi $sp, $sp, <stackslots>
        mips.Add freeStack = new mips.Add(new mips.Reg("sp"), new mips.Reg("sp"), new DecConst(getStackSlots()));
        stmts.add(freeStack);
        
        // jump back
        stmts.add(new J(new mips.Reg("ra")));
        
        return stmts;
    }
    
    
    /*
     * Statements
     */
    syn lazy mips.List<mips.Stmt> Stmt.toMips() = convertToStmtList(new mips.Label("NOT IMPLEMENTED"));
    eq Noop.toMips() = convertToStmtList(new mips.Nop());
    eq Err.toMips() = convertToStmtList(new J(new IdConst("_error")));
    eq CJump.toMips() = convertToStmtList(new mips.Beqz(getCond().toMips(), getLabel().toMipsOperand())); // TODO invert cond?
    // eq Jump.toMips() = convertToStmtList(new mips.J(...));
    // eq HStore.toMips() = // Addr:Reg <Offset:Integer> Value:Reg;
    // eq HLoad.toMips() = // Dest:Reg Addr:Reg <Offset:Integer>;
    // eq Move.toMips() = convertToStmtList(new mips.Move(getDest().toMips(), getAddr).toMips()); // TODO add <Offset:Integer>
    // eq Print.toMips() = // Value:SExp; // TODO syscall 
    // eq ALoad.toMips() = new mips.Lw(...) // Dest:Reg StackPos:SpilledArg;
    // eq AStore.toMips() = new mips.Sw(...) // StackPos:SpilledArg Value:Reg;
    // eq PassArg.toMips() =  // <StackIndex:Integer> Value:Reg;
    // eq Call.toMips() = new mips.Jalr(...) // Addr:SExp;

    
    /*
     * Expressions
     */
    /*
    abstract Exp;
    HAlloc:Exp  ::= Size:SExp;
    
    abstract SExp:Exp;
    Reg:SExp   ::= <Reg:String>;
    LabelExp:SExp ::= Label:Label;
    IntLiteral:SExp ::= <Integer:Integer>;
    
    abstract Binop:Exp  ::= Left:Reg Right:SExp;
    Lt:Binop;
    Plus:Binop;
    Minus:Binop;
    Times:Binop;
    */
    syn lazy mips.List<mips.Stmt> Exp.toMipsStmts() = new mips.List<mips.Stmt>();
    syn lazy mips.Reg Exp.toMipsReg() = new mips.Reg("meh");
    eq HAlloc.toMipsStmts() {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        // TODO Save current a0
        addAll(stmts, getSize().toMipsLoad(new mips.Reg("a0")));
        
        // Call halloc
        stmts.add(new Jal(new IdConst("_halloc")));
        
        return stmts;
    }
    eq HAlloc.toMipsReg() {
        return new mips.Reg("v0");
    }
    
    syn lazy mips.Reg Reg.toMips() = new mips.Reg(getReg());
    
    syn lazy mips.List<mips.Stmt> SExp.toMipsLoad(mips.Reg target);
    eq IntLiteral.toMipsLoad(mips.Reg target) {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        stmts.add(new Li(target, new DecConst(getInteger())));
        return stmts;
    }
    eq Reg.toMipsLoad(mips.Reg target) {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        stmts.add(new mips.Move(target, toMips()));
        return stmts;
    }
    eq LabelExp.toMipsLoad(mips.Reg target) {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        stmts.add(new mips.Move(target, getLabel().toMipsOperand()));
        return stmts;
    }
    
    /*
     * OTHER
     */
    syn lazy mips.Label Label.toMips() = new mips.Label(getLabel());
    syn lazy mips.IdConst Label.toMipsOperand() = new IdConst(getLabel());
    // SpilledArg  ::= <Pos:Integer>;
    

    /*
     * HELPERS
     */
    syn mips.List<mips.Stmt> Stmt.convertToStmtList(mips.Stmt stmt) {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        stmts.add(stmt);
        return stmts;
    }
    
    public void ASTNode.addAll(mips.List<mips.Stmt> statements, mips.List<mips.Stmt> additionalStatements) {
        for (mips.Stmt stmt: additionalStatements) {
            statements.add(stmt);
        }
    }
}