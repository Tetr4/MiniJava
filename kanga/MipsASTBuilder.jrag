import java.lang.Math;
import java.util.HashSet;
import java.util.HashMap;
import mips.*;

aspect MipsASTBuilder {
    
    
    private static void Program.reset() {
    }
     
    // Program
    syn lazy mips.Program Program.toMips() {
        // Reset builder state
        reset();
        
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        stmts.add(new Txt());
        stmts.add(new Globl("main"));
        stmts.add(new mips.Label("main"));
        
        // allocate stack space
        // subi $sp, $sp, <stackslots>
        // +4 due to $ra return address
        int requiredStackspace = getStackSlots() * 4 + 4;
        stmts.add(new mips.Sub(new mips.Reg("sp"), new mips.Reg("sp"), new DecConst(requiredStackspace)));
        
        // Save return address
        stmts.add(new mips.Sw(new mips.Reg("ra"), new AddrReg(new DecConst(requiredStackspace - 4), new mips.Reg("sp"))));
        
        // Labeled Statements
        for (LabeledStmt labeledStmt : getStmtsList()) {
            // add all
            for (mips.Stmt stmt : labeledStmt.toMips()) {
                stmts.add(stmt);
            }
        }
        
        // Restore return address
        stmts.add(new mips.Lw(new mips.Reg("ra"), new AddrReg(new DecConst(requiredStackspace - 4), new mips.Reg("sp"))));
        
        // free stack space
        // addi $sp, $sp, <stackslots>
        stmts.add(new mips.Add(new mips.Reg("sp"), new mips.Reg("sp"), new DecConst(requiredStackspace)));
        
        // jump back
        stmts.add(new J(new mips.Reg("ra")));
        
        // Procedures
        for (Procedure procedure : getProcsList()) {
            // add all
            for (mips.Stmt stmt : procedure.toMips()) {
                stmts.add(stmt);
            }
        }
        
        // Add predefined helpers:
        // _halloc!
        stmts.add(new Txt());
        stmts.add(new Globl("_halloc"));
        stmts.add(new mips.Label("_halloc"));
        stmts.add(new Li(new mips.Reg("v0"), new DecConst(9))); // sbrk (alloc)
        stmts.add(new Syscall());
        stmts.add(new J(new mips.Reg("ra")));
        
        // _print
        stmts.add(new Globl("_print"));
        stmts.add(new mips.Label("_print"));
        stmts.add(new Li(new mips.Reg("v0"), new DecConst(1))); // print int
        stmts.add(new Syscall());
        stmts.add(new La(new mips.Reg("a0"), new IdConst("newl")));
        stmts.add(new Li(new mips.Reg("v0"), new DecConst(4))); // print string
        stmts.add(new Syscall());
        stmts.add(new J(new mips.Reg("ra")));
        
        // _error
        stmts.add(new Globl("_error"));
        stmts.add(new mips.Label("_error"));
        stmts.add(new La(new mips.Reg("a0"), new IdConst("str_er")));
        stmts.add(new Li(new mips.Reg("v0"), new DecConst(4))); // print string
        stmts.add(new Syscall());
        stmts.add(new Li(new mips.Reg("v0"), new DecConst(10))); // exit
        stmts.add(new Syscall());
        
        // newl   
        stmts.add(new Dat());
        stmts.add(new Align(0));
        stmts.add(new mips.Label("newl"));
        stmts.add(new Data(new Asciiz(), new StringData("\\n")));
        
        // str_er
        stmts.add(new mips.Label("str_er"));
        stmts.add(new Data(new Asciiz(), new StringData("ERROR\\n"))); 
        
        return new mips.Program(stmts);
    }
    
    // LabeledStmt
    syn lazy mips.List<mips.Stmt> LabeledStmt.toMips() {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        // Label
        if(hasLabel()) {
            stmts.add(getLabel().toMips());
        }
        
        // Statement
        for (mips.Stmt stmt : getStmt().toMips()) {
            stmts.add(stmt);
        }
        return stmts;
    }
    
    // Procedure
    syn lazy mips.List<mips.Stmt> Procedure.toMips() {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        // globl
        stmts.add(new Txt());
        stmts.add(new Globl(getLabel().getLabel()));
        
        // label
        stmts.add(getLabel().toMips());
        
        // allocate stack space
        // subi $sp, $sp, <stackslots>
        // +4 due to $ra return address
        int requiredStackspace = getStackSlots() * 4 + 4;
        stmts.add(new mips.Sub(new mips.Reg("sp"), new mips.Reg("sp"), new DecConst(requiredStackspace)));
        
        // Save return address
        stmts.add(new mips.Sw(new mips.Reg("ra"), new AddrReg(new DecConst(requiredStackspace - 4), new mips.Reg("sp"))));
        
        // Labeled Statements
        for (LabeledStmt labeledStmt : getStmtsList()) {
            // add all
            for (mips.Stmt stmt : labeledStmt.toMips()) {
                stmts.add(stmt);
            }
        }
        
        // Restore return address
        stmts.add(new mips.Lw(new mips.Reg("ra"), new AddrReg(new DecConst(requiredStackspace - 4), new mips.Reg("sp"))));
        
        // free stack space
        // addi $sp, $sp, <stackslots>
        stmts.add(new mips.Add(new mips.Reg("sp"), new mips.Reg("sp"), new DecConst(requiredStackspace)));
        
        // jump back
        stmts.add(new J(new mips.Reg("ra")));
        
        return stmts;
    }
    
    
    /*
     * Statements
     */
    syn lazy mips.List<mips.Stmt> Stmt.toMips() = convertToStmtList(new mips.Label("NOT IMPLEMENTED"));
    eq Noop.toMips() = convertToStmtList(new mips.Nop());
    eq Err.toMips() = convertToStmtList(new J(new IdConst("_error")));
    eq CJump.toMips() = convertToStmtList(new mips.Beqz(getCond().toMipsReg(), getLabel().toMipsOperand()));
    eq Jump.toMips() = convertToStmtList(new mips.J(getLabel().toMipsOperand()));
    eq HStore.toMips() {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        AddrReg offsDest = new AddrReg(new DecConst(getOffset()), getAddr().toMipsReg());
        stmts.add(new mips.Sw(getValue().toMipsReg(), offsDest));
        
        return stmts;
    }
    eq HLoad.toMips() {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        AddrReg offsSource = new AddrReg(new DecConst(getOffset()), getAddr().toMipsReg());
        stmts.add(new mips.Lw(getDest().toMipsReg(), offsSource));
        
        return stmts;
    }
    eq Move.toMips() {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        addAll(stmts, getSource().toMipsLoad(getDest().toMipsReg()));
        
        return stmts;
    } 
    eq Print.toMips() {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        // Save a0 in t9!
        stmts.add(new mips.Move(new mips.Reg("v1"), new mips.Reg("a0")));
        
        addAll(stmts, getValue().toMipsLoad(new mips.Reg("a0")));
        stmts.add(new Jal(new IdConst("_print")));
        
        // Restore a0
        stmts.add(new mips.Move(new mips.Reg("a0"), new mips.Reg("v1")));
        
        return stmts;
    } 
    // eq ALoad.toMips() = new mips.Lw(...) // Dest:Reg StackPos:SpilledArg;
    // eq AStore.toMips() = new mips.Sw(...) // StackPos:SpilledArg Value:Reg;
    // eq PassArg.toMips() =  // <StackIndex:Integer> Value:Reg;
    eq Call.toMips() = convertToStmtList(getAddr().toMipsCall());

    
    /*
     * Expressions
     */
    /*
    abstract Exp;
    HAlloc:Exp  ::= Size:SExp;
    
    abstract SExp:Exp;
    Reg:SExp   ::= <Reg:String>;
    LabelExp:SExp ::= Label:Label;
    IntLiteral:SExp ::= <Integer:Integer>;
    
    abstract Binop:Exp  ::= Left:Reg Right:SExp;
    Lt:Binop;
    Plus:Binop;
    Minus:Binop;
    Times:Binop;
    */
    syn lazy mips.List<mips.Stmt> Exp.toMipsStmts() = new mips.List<mips.Stmt>();
    
    eq HAlloc.toMipsLoad(mips.Reg target) {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        
        // Save a0 in v1!
        stmts.add(new mips.Move(new mips.Reg("v1"), new mips.Reg("a0")));
        
        addAll(stmts, getSize().toMipsLoad(new mips.Reg("a0")));
        
        // Call halloc
        stmts.add(new Jal(new IdConst("_halloc")));
        
        // Save returned pointer
        stmts.add(new mips.Move(target, new mips.Reg("v0")));
        
        // Restore a0
        stmts.add(new mips.Move(new mips.Reg("a0"), new mips.Reg("v1")));
        
        return stmts;
    }
    
    // Binary expressions
    syn lazy mips.List<mips.Stmt> Exp.toMipsLoad(mips.Reg target);
    eq Lt.toMipsLoad(mips.Reg target) = convertToStmtList(new Slt(target, getLeft().toMipsOperand(), getRight().toMipsOperand()));
    eq Plus.toMipsLoad(mips.Reg target) = convertToStmtList(new Add(target, getLeft().toMipsOperand(), getRight().toMipsOperand()));
    eq Minus.toMipsLoad(mips.Reg target) = convertToStmtList(new Sub(target, getLeft().toMipsOperand(), getRight().toMipsOperand()));
    eq Times.toMipsLoad(mips.Reg target) = convertToStmtList(new Mul(target, getLeft().toMipsOperand(), getRight().toMipsOperand()));
    
    // Simple expressions
    eq IntLiteral.toMipsLoad(mips.Reg target) = convertToStmtList(new Li(target, toMipsOperand()));
    eq Reg.toMipsLoad(mips.Reg target) = convertToStmtList(new mips.Move(target, toMipsOperand()));
    eq LabelExp.toMipsLoad(mips.Reg target) = convertToStmtList(new mips.La(target, toMipsOperand()));
    
    syn lazy mips.Operand SExp.toMipsOperand();
    eq IntLiteral.toMipsOperand() = new DecConst(getInteger());
    eq Reg.toMipsOperand() = new mips.Reg(getReg());
    eq LabelExp.toMipsOperand() = getLabel().toMipsOperand();
    
    syn lazy mips.Reg Reg.toMipsReg() = (mips.Reg)toMipsOperand();
    
    // Generate correct jump and link instructions
    syn lazy mips.Stmt SExp.toMipsCall() = new Jal(toMipsOperand());
    eq Reg.toMipsCall() = new Jalr(toMipsOperand());
    
    /*
     * OTHER
     */
    syn lazy mips.Label Label.toMips() = new mips.Label(getLabel());
    syn lazy mips.IdConst Label.toMipsOperand() = new IdConst(getLabel());
    // SpilledArg  ::= <Pos:Integer>;
    

    /*
     * HELPERS
     */
    syn mips.List<mips.Stmt> ASTNode.convertToStmtList(mips.Stmt stmt) {
        mips.List<mips.Stmt> stmts = new mips.List<mips.Stmt>();
        stmts.add(stmt);
        return stmts;
    }
    
    public void ASTNode.addAll(mips.List<mips.Stmt> statements, mips.List<mips.Stmt> additionalStatements) {
        for (mips.Stmt stmt: additionalStatements) {
            statements.add(stmt);
        }
    }
}