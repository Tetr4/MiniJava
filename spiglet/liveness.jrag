import java.util.HashSet;
import java.util.Set;
import java.util.Arrays;
import java.util.Collections;

aspect LivenessAnalysis {
    // For the specification see docs/liveness.md
    
    
    /*
     * Pos
     */
    syn lazy int LabeledStmt.pos() {
        return getParentStmts().getIndexOfChild(this);
    }
    syn lazy int Stmt.pos() {
        if(getParent() instanceof LabeledStmt) {
            LabeledStmt labeledStmt = (LabeledStmt) getParent();
            return labeledStmt.pos();
        }
        throw new IllegalStateException("Statement has no LabeledStmt as parent!");
    }
    syn lazy int Label.pos() {
        // search matching label in labeledStmts
        for(LabeledStmt labeledStmt : getParentStmts()) {
            if(!labeledStmt.hasLabel()) continue;
            String labelString = labeledStmt.getLabel().getLabel();
            if(getLabel().equals(labelString)) {
                return labeledStmt.pos();
            }
        }
        throw new IllegalStateException("Found no matching label for label: "+ getLabel() +"!");
    }
    
    
    /*
     * Flow specification 
     */
    syn lazy Set<Integer> Stmt.nextPos() {
        boolean parentIsProgram = getParentProgramOrProcedure() instanceof Program;
        boolean isLastPos = pos() == getParentStmts().getNumChild()-1;
        if(parentIsProgram && isLastPos) {
            // If this statement is the last in the list, it has no successor.
            return Collections.emptySet();
        }
        
        // Return the position of the next statement after this one.
        // In a procedure this may be the position of the RetExp.
        return new HashSet<Integer>(Arrays.asList( pos()+1 ));
    }
    syn lazy boolean Procedure.isRetExpPos(int pos) = pos == getStmtsRet().getStmtsList().getNumChild();
    
    syn lazy Set<Integer> Program.flow(int pos) = getStmtsList().getChild(pos).flow();
    syn lazy Set<Integer> Procedure.flow(int pos) {
        if(isRetExpPos(pos)) {
            // no successor after RetExp
            return Collections.emptySet();
        }
        return getStmtsRet().getStmtsList().getChild(pos).flow();
    }
    syn lazy Set<Integer> LabeledStmt.flow() = getStmt().flow();
    syn lazy Set<Integer> Stmt.flow() = nextPos();
    eq Err.flow() = Collections.emptySet();
    eq CJump.flow() {
        Set<Integer> set = nextPos();
        set.add(getLabel().pos());
        return set;
    }
    eq Jump.flow() = new HashSet<Integer>(Arrays.asList( getLabel().pos() ));
    
    
    /*
     * Def specification 
     */
    syn lazy Set<Temp> Program.def(int pos) = getStmtsList().getChild(pos).def();
    syn lazy Set<Temp> Procedure.def(int pos) {
        if(isRetExpPos(pos)) {
            // RetExp doesn't define any temps
            return Collections.emptySet();
        }
        return getStmtsRet().getStmtsList().getChild(pos).def();
    }
    syn lazy Set<Temp> LabeledStmt.def() = getStmt().def();
    syn lazy Set<Temp> Stmt.def() = Collections.emptySet();
    eq HStore.def() = new HashSet<Temp>(Arrays.asList( getAddr() ));
    eq HLoad.def() = new HashSet<Temp>(Arrays.asList( getDest() ));
    eq Move.def() = new HashSet<Temp>(Arrays.asList( getDest() ));
    
    
    /*
     * Use specification 
     */
    syn lazy Set<Temp> Program.use(int pos) = getStmtsList().getChild(pos).use();
    syn lazy Set<Temp> Procedure.use(int pos) {
        if(isRetExpPos(pos)) {
            return getStmtsRet().getRetExp().use();
        }
        return getStmtsRet().getStmtsList().getChild(pos).use();
    }
    syn lazy Set<Temp> LabeledStmt.use() = getStmt().use();
    syn lazy Set<Temp> Stmt.use() = Collections.emptySet();
    eq CJump.use() = new HashSet<Temp>(Arrays.asList( getCond() ));
    eq HStore.use() = new HashSet<Temp>(Arrays.asList( getValue() ));
    eq HLoad.use() = new HashSet<Temp>(Arrays.asList( getAddr() ));
    eq Move.use() = getSource().use();
    eq Print.use() = getValue().use();
	
	// Exp use
    syn lazy Set<Temp> Exp.use();
    eq HAlloc.use() = getSize().use();
    eq Call.use() {
        Set<Temp> temps = new HashSet<Temp>();
        temps.addAll(getName().use());
        for(Temp param : getParamList()) {
            temps.add(param);
        }
        return temps;
    }
    eq Binop.use() {
        Set<Temp> temps = new HashSet<Temp>();
        temps.add(getLeft());
        temps.addAll(getRight().use());
        return temps;    
    }

    // SExp use
    eq TempExp.use() = new HashSet<Temp>(Arrays.asList( getTemp() ));
    eq LabelExp.use() = Collections.emptySet();
    eq IntLiteral.use() = Collections.emptySet();
    
    
    /*
     * Helper
     */
    syn lazy List<LabeledStmt> ASTNode.getParentStmts() {
        ASTNode<T> parent = getParentProgramOrProcedure();
        
        if (parent instanceof Procedure) {
            Procedure procedure = (Procedure)parent;
            return procedure.getStmtsRet().getStmtsList();
        } else {
            Program program = (Program)parent;
            return program.getStmtsList();
        }
    } 
    
    syn lazy ASTNode<T> ASTNode.getParentProgramOrProcedure() {
        // search procedure or program
        ASTNode<T> parent = this;
        List<LabeledStmt> labeledStmts;
        do {
            if (parent instanceof Procedure || parent instanceof Program) {
                return parent;
            }
            
            parent = parent.getParent();
        } while(parent != null);
        
        throw new IllegalStateException("Node has no procedure or program as parent!");
    } 
    
    // Allow comparing of Temps in HashSet operations 
    public int Temp.hashCode() {
        return getNumber().hashCode();
    }
    public boolean Temp.equals(Object obj) {
       if (!(obj instanceof Temp))
            return false;
        if (obj == this)
            return true;
        Temp other = (Temp) obj;
        return getNumber().equals(other.getNumber());
    }
} 