import java.lang.Math;
import java.util.HashSet;

aspect KangaASTBuilder {
    /*
     * 24 registers:
     * s0-s7 <- callee-saved
     * t0-t9 <- callee-clobbered
     * a0-a3 <- arguments
     * v0    <- return
     * v0,v1 <- temporary for loading from stack
     */ 
     
    // Program
    syn lazy kanga.Program Program.toKanga() {
        kanga.List stmts = getStmtsList().toKanga();
        kanga.List procs = getProcsList().toKanga();

        // Count maximal number of parameters of a call.
        int maxParamsOfCalls = getMaxParams(getStmtsList());
        
        // Calculate required stack slots
        // See Procedure.getStackSlots()
        HashSet<Integer> temps = new HashSet<Integer>();
        getStmtsList().collectTemps(temps, 0);
        
        int localVariableStackSlots = temps.size();
        localVariableStackSlots = Math.max(0, localVariableStackSlots - 10);
        
        int numSpilledArgs = Math.max(0, maxParamsOfCalls - 4);
        int numStackSlots = localVariableStackSlots + numSpilledArgs;
        
        return new kanga.Program(numStackSlots, maxParamsOfCalls, stmts, procs);
    }

    // LabeledStmt    
    syn lazy kanga.LabeledStmt LabeledStmt.toKanga() {
        kanga.Opt<kanga.Label> opt;
        if(hasLabel()) {
            opt = new kanga.Opt<kanga.Label>(getLabel().toKanga());
        } else {
            opt = new kanga.Opt<kanga.Label>();
        }
        return new kanga.LabeledStmt(opt, getStmt().toKanga());
    }
    
    // Procedure
    syn lazy kanga.Procedure Procedure.toKanga() {
        int maxParams = getMaxParams(getStmtsRet().getStmtsList());
        return new kanga.Procedure(getLabel().toKanga(), getParams(), getStackSlots(), maxParams, getStmtsRet().toKanga()); 
    }
    
    syn lazy int Procedure.getStackSlots() {
    
        // We have 4 registers for arguments.
        // If this procedure takes more arguments, they are put on the stack.
        int argumentsStackSlots = Math.max(0, getParams() - 4);
    
        // Check how many temporaries were used in this procedure.
		HashSet<Integer> temps = new HashSet<Integer>();
		collectTemps(temps, getParams());
		
        // Ignore the arguments as they are stored in Temp(0) - Temp(numargs-1)
		int localVariableStackSlots = temps.size();
		// We have 10 t<x> registers t0 - t9. We start using spilled temporaries if we exceed 10 temps.
		// Saved registers s0 - s7 require us to save the old value on the stack when they're used.
		// So we don't really save a stack slot by using registers s0 - s7, 
		// because we have to use one stack slot to save the old value.
		localVariableStackSlots = Math.max(0, localVariableStackSlots - 10);
		
		// Check spilled args of calls
		// Get maximum number of passed parameters of a call in our body.
		int maxParamsOfCalls = getMaxParams(getStmtsRet().getStmtsList());
		// We'd overwrite the a0 - a3 registers holding our own arguments
		// when calling a function, so we have to save them before specifying the arguments of the call.
		// Effectively we'd only save a stack slot for the unused argument registers, if our procedure uses less than 4.
		int numFreeArgumentRegisters = 4 - Math.max(getParams(), 4);
		int numSpilledArgs = Math.max(0, maxParamsOfCalls - numFreeArgumentRegisters);
		
		return argumentsStackSlots + localVariableStackSlots + numSpilledArgs;
    }
    
    // Check all children and find temporaries!
    public void ASTNode.collectTemps(HashSet<Integer> temps, int minTempNumber) {
        for (ASTNode<ASTNode> node: this) {
            node.collectTemps(temps, minTempNumber);
        }
    }
    
    // Add the number of this temp to the set. No duplicates!
    public void Temp.collectTemps(HashSet<Integer> temps, int minTempNumber) {
        if(minTempNumber <= getNumber()) {
            temps.add(getNumber());
        }
    }
            
    public static int ASTNode.getMaxParams(List<LabeledStmt> labeledStmts) {
        int maxParams = 0;
        
        // Calls can only happen as the "source" of a Move statement.
        // Check all Move statements in the Procedure for calls and find the one with the maximal params.
        for(LabeledStmt labeledStmt : labeledStmts) {
            Stmt stmt = labeledStmt.getStmt();
            if(stmt instanceof Move) {
                Move move = (Move)stmt;
                if(move.getSource() instanceof Call) {
                    Call call = (Call)move.getSource();
                    maxParams = Math.max(maxParams, call.getNumParam());
                } 
            }
        }
        
        return maxParams;
    }

    
    /*
     * Statements
     */
    syn lazy kanga.Stmt Stmt.toKanga();
    eq Noop.toKanga() = new kanga.Noop();
    eq Err.toKanga() = new kanga.Err();
    eq CJump.toKanga() = new kanga.CJump(getCond().toKanga(), getLabel().toKanga());
    eq Jump.toKanga() = new kanga.Jump(getLabel().toKanga());
    eq HStore.toKanga() = new kanga.HStore(getAddr().toKanga(), getOffset(), getValue().toKanga());
    eq HLoad.toKanga() = new kanga.HLoad(getDest().toKanga(), getAddr().toKanga(), getOffset());
    eq Move.toKanga() = new kanga.Move(getDest().toKanga(), getSource().toKanga());
    eq Print.toKanga() = new kanga.Print((kanga.SExp) getValue().toKanga());

    
    /*
     * Expressions
     */
    // TODO maybe return kanga.List<kanga.LabeledStmt> for prologue/epilog ?
    syn lazy kanga.Exp Exp.toKanga() = null; // TODO
    // Call:Exp      ::= Name:SExp Param:Temp*;
    // HAlloc:Exp   ::= Size:SExp;
    
    // TempExp:SExp     ::= Temp:Temp;
    // LabelExp:SExp ::= Label:Label;
    // IntLiteral:SExp ::= <Integer:Integer>;
    
    eq Lt.toKanga() = new kanga.Lt(getLeft().toKanga(), (kanga.SExp) getRight().toKanga());
    eq Plus.toKanga() = new kanga.Plus(getLeft().toKanga(), (kanga.SExp) getRight().toKanga());
    eq Minus.toKanga() = new kanga.Minus(getLeft().toKanga(), (kanga.SExp) getRight().toKanga());
    eq Times.toKanga() = new kanga.Times(getLeft().toKanga(), (kanga.SExp) getRight().toKanga());

    
    /*
     * OTHER
     */
    // StmtExp
    syn lazy kanga.List<kanga.LabeledStmt> StmtExp.toKanga() = null; // TODO
    
    // Temp
    syn lazy kanga.Reg Temp.toKanga() = null; // TODO
    
    // Label
    syn lazy kanga.Label Label.toKanga() = new kanga.Label(getLabel());
    


    /*
     * HELPERS
     */
    syn lazy kanga.List List.toKanga() {
        kanga.List list = new kanga.List();
        for (ASTNode node: this) {
            // FIXME transformable interface or instanceof ?
            
            //kanga.ASTNode kangaNode = node.toKanga();
            //list.addChild(kangaNode);
        }
        return list;
    }

    
}